diff --git a/src/plugins/imageformats/svg/CMakeLists.txt b/src/plugins/imageformats/svg/CMakeLists.txt
index 140e281..ec69a02 100644
--- a/src/plugins/imageformats/svg/CMakeLists.txt
+++ b/src/plugins/imageformats/svg/CMakeLists.txt
@@ -14,5 +14,5 @@ qt_internal_add_plugin(QSvgPlugin
     LIBRARIES
         Qt::Core
         Qt::Gui
-        Qt::Svg
+        Qt::SvgPrivate
 )
diff --git a/src/plugins/imageformats/svg/qsvgiohandler.cpp b/src/plugins/imageformats/svg/qsvgiohandler.cpp
index 570c982..1212f80 100644
--- a/src/plugins/imageformats/svg/qsvgiohandler.cpp
+++ b/src/plugins/imageformats/svg/qsvgiohandler.cpp
@@ -6,6 +6,7 @@
 #ifndef QT_NO_SVGRENDERER
 
 #include "qsvgrenderer.h"
+#include "private/qsvgtinydocument_p.h"
 #include "qimage.h"
 #include "qpixmap.h"
 #include "qpainter.h"
@@ -84,25 +85,6 @@ QSvgIOHandler::~QSvgIOHandler()
     delete d;
 }
 
-static bool isPossiblySvg(QIODevice *device, bool *isCompressed = nullptr)
-{
-    constexpr int bufSize = 64;
-    char buf[bufSize];
-    const qint64 readLen = device->peek(buf, bufSize);
-    if (readLen < 8)
-        return false;
-#    ifndef QT_NO_COMPRESS
-    if (quint8(buf[0]) == 0x1f && quint8(buf[1]) == 0x8b) {
-        if (isCompressed)
-            *isCompressed = true;
-        return true;
-    }
-#    endif
-    QTextStream str(QByteArray::fromRawData(buf, readLen));
-    QByteArray ba = str.read(16).trimmed().toLatin1();
-    return ba.startsWith("<?xml") || ba.startsWith("<svg") || ba.startsWith("<!--") || ba.startsWith("<!DOCTYPE svg");
-}
-
 bool QSvgIOHandler::canRead() const
 {
     if (!device())
@@ -111,7 +93,7 @@ bool QSvgIOHandler::canRead() const
         return true;        // Will happen if we have been asked for the size
 
     bool isCompressed = false;
-    if (isPossiblySvg(device(), &isCompressed)) {
+    if (QSvgTinyDocument::isLikelySvg(device(), &isCompressed)) {
         setFormat(isCompressed ? "svgz" : "svg");
         return true;
     }
@@ -237,7 +219,7 @@ bool QSvgIOHandler::supportsOption(ImageOption option) const
 
 bool QSvgIOHandler::canRead(QIODevice *device)
 {
-    return isPossiblySvg(device);
+    return QSvgTinyDocument::isLikelySvg(device);
 }
 
 QT_END_NAMESPACE
diff --git a/src/svg/CMakeLists.txt b/src/svg/CMakeLists.txt
index 7b9c462..c958d6e 100644
--- a/src/svg/CMakeLists.txt
+++ b/src/svg/CMakeLists.txt
@@ -21,10 +21,15 @@ qt_internal_add_module(Svg
         qsvgnode.cpp qsvgnode_p.h
         qsvgrenderer.cpp qsvgrenderer.h
         qsvgstructure.cpp qsvgstructure_p.h
+        qsvgfilter.cpp qsvgfilter_p.h
         qsvgstyle.cpp qsvgstyle_p.h
         qsvgtinydocument.cpp qsvgtinydocument_p.h
+        qsvghelper_p.h
+        qsvgdebug.cpp
+        qsvgvisitor.cpp qsvgvisitor_p.h
         qtsvgglobal.h qtsvgglobal_p.h
     DEFINES
+        QT_NO_CONTEXTLESS_CONNECT
         QT_NO_USING_NAMESPACE
     LIBRARIES
         Qt::CorePrivate
@@ -36,7 +41,6 @@ qt_internal_add_module(Svg
         Qt::CorePrivate
         Qt::GuiPrivate
     GENERATE_CPP_EXPORTS
-    GENERATE_PRIVATE_CPP_EXPORTS
 )
 
 ## Scopes:
diff --git a/src/svg/doc/src/svgrendering.qdoc b/src/svg/doc/src/svgrendering.qdoc
index 4fa37fe..0edc039 100644
--- a/src/svg/doc/src/svgrendering.qdoc
+++ b/src/svg/doc/src/svgrendering.qdoc
@@ -28,8 +28,11 @@
     can read more about SVG at \l{About SVG}.
 
     Qt supports the \l{SVG 1.2 Tiny Static Features}{static features} of
-    \l{http://www.w3.org/TR/SVGMobile12}{SVG 1.2 Tiny}. ECMA scripts and DOM manipulation are currently not
-    supported.
+    \l{http://www.w3.org/TR/SVGMobile12}{SVG 1.2 Tiny}. ECMA scripts and DOM
+    manipulation are currently not supported.
+
+    Since Qt 6.7, some \l{Extended Features}{additional features} of the
+    \l{https://www.w3.org/TR/SVG11/}{SVG 1.1} standard are supported.
 
     SVG drawings can be rendered onto any QPaintDevice subclass. This
     approach gives developers the flexibility to experiment, in order
diff --git a/src/svg/qsvgdebug.cpp b/src/svg/qsvgdebug.cpp
new file mode 100644
index 0000000..a3cdf8d
--- /dev/null
+++ b/src/svg/qsvgdebug.cpp
@@ -0,0 +1,185 @@
+// Copyright (C) 2023 The Qt Company Ltd.
+// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
+
+#include "qsvgvisitor_p.h"
+#include <QDebug>
+
+QT_BEGIN_NAMESPACE
+
+static const char *nodeTypeStrings[] = {
+    "DOC",
+    "G",
+    "DEFS",
+    "SWITCH",
+    "ANIMATION",
+    "ARC",
+    "CIRCLE",
+    "ELLIPSE",
+    "IMAGE",
+    "LINE",
+    "PATH",
+    "POLYGON",
+    "POLYLINE",
+    "RECT",
+    "TEXT",
+    "TEXTAREA",
+    "TSPAN",
+    "USE",
+    "VIDEO"
+};
+
+// TODO: something like this is needed in several places. Make a common version.
+static const char *typeName(const QSvgNode *node)
+{
+    constexpr int typeNameCount = sizeof(nodeTypeStrings) / sizeof(const char *);
+    if (node->type() < typeNameCount)
+        return nodeTypeStrings[node->type()];
+    return "UNKNOWN";
+}
+
+class SvgDebugVisitor : public QSvgVisitor
+{
+public:
+    SvgDebugVisitor(QDebug &stream) : debug(stream) {}
+    void write(const QSvgTinyDocument *doc);
+
+protected:
+    void visitNode(const QSvgNode *) override;
+    bool visitStructureNodeStart(const QSvgStructureNode *node) override;
+    void visitStructureNodeEnd(const QSvgStructureNode *) override;
+    void visitAnimationNode(const QSvgAnimation *node) override;
+    void visitEllipseNode(const QSvgEllipse *node) override;
+    void visitImageNode(const QSvgImage *node) override;
+    void visitLineNode(const QSvgLine *node) override;
+    void visitPathNode(const QSvgPath *node) override;
+    void visitPolygonNode(const QSvgPolygon *node) override;
+    void visitPolylineNode(const QSvgPolyline *node) override;
+    void visitRectNode(const QSvgRect *node) override;
+    void visitTextNode(const QSvgText *node) override;
+    void visitUseNode(const QSvgUse *node) override;
+    void visitVideoNode(const QSvgVideo *node) override;
+
+private:
+    const char *indent() { m_indent.fill(' ', m_indentLevel * 2);  return m_indent.constData();}
+    void handleBaseNode(const QSvgNode *node);
+    QDebug &debug;
+    int m_indentLevel = 0;
+    QByteArray m_indent;
+    int nodeCounter = 0;
+};
+
+void SvgDebugVisitor::handleBaseNode(const QSvgNode *node)
+{
+    debug << indent() << typeName(node) << "node, ID:" << node->nodeId();
+    nodeCounter++;
+}
+
+void SvgDebugVisitor::visitNode(const QSvgNode *node)
+{
+    handleBaseNode(node);
+    debug << Qt::endl;
+}
+
+bool SvgDebugVisitor::visitStructureNodeStart(const QSvgStructureNode *node)
+{
+    debug << indent() << "START node" << node->nodeId() << "type" << typeName(node) << node->type() << Qt::endl;
+    m_indentLevel++;
+    return true;
+}
+
+void SvgDebugVisitor::visitStructureNodeEnd(const QSvgStructureNode *node)
+{
+    m_indentLevel--;
+    debug << indent() << "END node" << node->nodeId() << Qt::endl;
+}
+
+void SvgDebugVisitor::visitAnimationNode(const QSvgAnimation *node)
+{
+    handleBaseNode(node);
+    debug << Qt::endl;
+}
+
+void SvgDebugVisitor::visitEllipseNode(const QSvgEllipse *node)
+{
+    handleBaseNode(node);
+    debug << "rect:" << node->rect() << Qt::endl;
+}
+
+void SvgDebugVisitor::visitImageNode(const QSvgImage *node)
+{
+    handleBaseNode(node);
+    debug << "image:" << node->image() << Qt::endl;
+}
+
+void SvgDebugVisitor::visitLineNode(const QSvgLine *node)
+{
+    handleBaseNode(node);
+    debug << "line:" << node->line() << Qt::endl;
+}
+
+void SvgDebugVisitor::visitPathNode(const QSvgPath *node)
+{
+    handleBaseNode(node);
+    debug << "path:" << node->path().elementCount() << "elements." << Qt::endl;
+}
+
+void SvgDebugVisitor::visitPolygonNode(const QSvgPolygon *node)
+{
+    handleBaseNode(node);
+    debug << "polygon:" << node->polygon().size() << "elements." << Qt::endl;
+}
+
+void SvgDebugVisitor::visitPolylineNode(const QSvgPolyline *node)
+{
+    handleBaseNode(node);
+    debug << "polygon:" << node->polygon().size() << "elements." << Qt::endl;
+}
+
+void SvgDebugVisitor::visitRectNode(const QSvgRect *node)
+{
+    handleBaseNode(node);
+    debug << "rect:" << node->rect() << "radius:" << node->radius() << Qt::endl;
+}
+
+void SvgDebugVisitor::visitTextNode(const QSvgText *node)
+{
+    handleBaseNode(node);
+    QString text;
+    for (const auto *tspan : node->tspans()) {
+        if (!tspan)
+            text += QStringLiteral("\\n");
+        else
+            text += tspan->text();
+    }
+    debug << "text:" << text << Qt::endl;
+}
+
+void SvgDebugVisitor::visitUseNode(const QSvgUse *node)
+{
+    handleBaseNode(node);
+    debug << "link ID:" << node->linkId() << Qt::endl;
+}
+
+void SvgDebugVisitor::visitVideoNode(const QSvgVideo *node)
+{
+    handleBaseNode(node);
+    debug << Qt::endl;
+}
+
+void SvgDebugVisitor::write(const QSvgTinyDocument *doc)
+{
+    debug << "SVG" << doc->size() << "viewBox" << doc->viewBox() << Qt::endl;
+    traverse(doc);
+
+    debug << "END SVG" << nodeCounter << "nodes";
+}
+
+QDebug operator<<(QDebug debug, const QSvgTinyDocument &doc)
+{
+    SvgDebugVisitor visitor(debug);
+    visitor.write(&doc);
+
+    return debug;
+}
+
+QT_END_NAMESPACE
diff --git a/src/svg/qsvgfilter.cpp b/src/svg/qsvgfilter.cpp
new file mode 100644
index 0000000..f773ec6
--- /dev/null
+++ b/src/svg/qsvgfilter.cpp
@@ -0,0 +1,678 @@
+// Copyright (C) 2023 The Qt Company Ltd.
+// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
+
+#include "qsvgfilter_p.h"
+
+#include "qsvgnode_p.h"
+#include "qsvgtinydocument_p.h"
+#include "qpainter.h"
+
+#include <QLoggingCategory>
+#include <QtGui/qimageiohandler.h>
+#include <QVector4D>
+
+QT_BEGIN_NAMESPACE
+
+Q_DECLARE_LOGGING_CATEGORY(lcSvgDraw);
+
+QSvgFeFilterPrimitive::QSvgFeFilterPrimitive(QSvgNode *parent, QString input, QString result,
+                                             const QSvgRectF &rect)
+    : QSvgStructureNode(parent)
+    , m_input(input)
+    , m_result(result)
+    , m_rect(rect)
+{
+
+}
+
+QRectF QSvgFeFilterPrimitive::localFilterBoundingBox(QSvgNode *node,
+                                                     const QRectF &itemBounds, const QRectF &filterBounds,
+                                                     QtSvg::UnitTypes primitiveUnits, QtSvg::UnitTypes filterUnits) const
+{
+
+    QRectF localBounds;
+    if (filterUnits != QtSvg::UnitTypes::userSpaceOnUse)
+        localBounds = itemBounds;
+    else
+        localBounds = filterBounds;
+    QRectF clipRect = m_rect.combinedWithLocalRect(localBounds, node->document()->viewBox(), primitiveUnits);
+    clipRect = clipRect.intersected(filterBounds);
+
+    return clipRect;
+}
+
+QRectF QSvgFeFilterPrimitive::globalFilterBoundingBox(QSvgNode *item, QPainter *p,
+                                                      const QRectF &itemBounds, const QRectF &filterBounds,
+                                                      QtSvg::UnitTypes primitiveUnits, QtSvg::UnitTypes filterUnits) const
+{
+    return p->transform().mapRect(localFilterBoundingBox(item, itemBounds, filterBounds, primitiveUnits, filterUnits));
+}
+
+void QSvgFeFilterPrimitive::clipToTransformedBounds(QImage *buffer, QPainter *p, const QRectF &localRect) const
+{
+    QPainter painter(buffer);
+    painter.setRenderHints(p->renderHints());
+    painter.translate(-buffer->offset());
+    QPainterPath clipPath;
+    clipPath.setFillRule(Qt::OddEvenFill);
+    clipPath.addRect(QRect(buffer->offset(), buffer->size()).adjusted(-10, -10, 20, 20));
+    clipPath.addPolygon(p->transform().map(QPolygonF(localRect)));
+    painter.setCompositionMode(QPainter::CompositionMode_SourceIn);
+    painter.fillPath(clipPath, Qt::transparent);
+}
+
+bool QSvgFeFilterPrimitive::requiresSourceAlpha() const
+{
+    return m_input == QLatin1StringView("SourceAlpha");
+}
+
+const QSvgFeFilterPrimitive *QSvgFeFilterPrimitive::castToFilterPrimitive(const QSvgNode *node)
+{
+    if (node->type() == QSvgNode::FeMerge ||
+        node->type() == QSvgNode::FeColormatrix ||
+        node->type() == QSvgNode::FeGaussianblur ||
+        node->type() == QSvgNode::FeOffset ||
+        node->type() == QSvgNode::FeComposite ||
+        node->type() == QSvgNode::FeFlood ) {
+        return reinterpret_cast<const QSvgFeFilterPrimitive*>(node);
+    } else {
+        return nullptr;
+    }
+}
+
+QSvgFeColorMatrix::QSvgFeColorMatrix(QSvgNode *parent, QString input, QString result, const QSvgRectF &rect,
+                                     ColorShiftType type, Matrix matrix)
+    : QSvgFeFilterPrimitive(parent, input, result, rect)
+    , m_type(type)
+    , m_matrix(matrix)
+{
+    (void)m_type;
+    //Magic numbers see SVG 1.1(Second edition)
+    if (type == ColorShiftType::Saturate) {
+        qreal s = qBound(0., matrix.data()[0], 1.);
+
+        m_matrix.fill(0);
+
+        m_matrix.data()[0+0*5] = 0.213f + 0.787f * s;
+        m_matrix.data()[1+0*5] = 0.715f - 0.717f * s;
+        m_matrix.data()[2+0*5] = 0.072f - 0.072f * s;
+
+        m_matrix.data()[0+1*5] = 0.213f - 0.213f * s;
+        m_matrix.data()[1+1*5] = 0.715f + 0.285f * s;
+        m_matrix.data()[2+1*5] = 0.072f - 0.072f * s;
+
+        m_matrix.data()[0+2*5] = 0.213f - 0.213f * s;
+        m_matrix.data()[1+2*5] = 0.715f - 0.715f * s;
+        m_matrix.data()[2+2*5] = 0.072f + 0.928f * s;
+
+        m_matrix.data()[3+3*5] = 1;
+
+    } else if (type == ColorShiftType::HueRotate){
+        qreal angle = matrix.data()[0]/180.*M_PI;
+        qreal s = sin(angle);
+        qreal c = cos(angle);
+
+        m_matrix.fill(0);
+
+        QMatrix3x3 m1;
+        m1.data()[0+0*3] = 0.213f;
+        m1.data()[1+0*3] = 0.715f;
+        m1.data()[2+0*3] = 0.072f;
+
+        m1.data()[0+1*3] = 0.213f;
+        m1.data()[1+1*3] = 0.715f;
+        m1.data()[2+1*3] = 0.072f;
+
+        m1.data()[0+2*3] = 0.213f;
+        m1.data()[1+2*3] = 0.715f;
+        m1.data()[2+2*3] = 0.072f;
+
+        QMatrix3x3 m2;
+        m2.data()[0+0*3] = 0.787 * c;
+        m2.data()[1+0*3] = -0.715 * c;
+        m2.data()[2+0*3] = -0.072 * c;
+
+        m2.data()[0+1*3] = -0.213 * c;
+        m2.data()[1+1*3] = 0.285 * c;
+        m2.data()[2+1*3] = -0.072 * c;
+
+        m2.data()[0+2*3] = -0.213 * c;
+        m2.data()[1+2*3] = -0.715 * c;
+        m2.data()[2+2*3] = 0.928 * c;
+
+        QMatrix3x3 m3;
+        m3.data()[0+0*3] = -0.213 * s;
+        m3.data()[1+0*3] = -0.715 * s;
+        m3.data()[2+0*3] = 0.928 * s;
+
+        m3.data()[0+1*3] = 0.143 * s;
+        m3.data()[1+1*3] = 0.140 * s;
+        m3.data()[2+1*3] = -0.283 * s;
+
+        m3.data()[0+2*3] = -0.787 * s;
+        m3.data()[1+2*3] = 0.715 * s;
+        m3.data()[2+2*3] = 0.072 * s;
+
+        QMatrix3x3 m = m1 + m2 + m3;
+
+        m_matrix.data()[0+0*5] = m.data()[0+0*3];
+        m_matrix.data()[1+0*5] = m.data()[1+0*3];
+        m_matrix.data()[2+0*5] = m.data()[2+0*3];
+
+        m_matrix.data()[0+1*5] = m.data()[0+1*3];
+        m_matrix.data()[1+1*5] = m.data()[1+1*3];
+        m_matrix.data()[2+1*5] = m.data()[2+1*3];
+
+        m_matrix.data()[0+2*5] = m.data()[0+2*3];
+        m_matrix.data()[1+2*5] = m.data()[1+2*3];
+        m_matrix.data()[2+2*5] = m.data()[2+2*3];
+
+        m_matrix.data()[3+3*5] = 1;
+    } else if (type == ColorShiftType::LuminanceToAlpha){
+        m_matrix.fill(0);
+
+        m_matrix.data()[0+3*5] = 0.2125;
+        m_matrix.data()[1+3*5] = 0.7154;
+        m_matrix.data()[2+3*5] = 0.0721;
+    }
+}
+
+QSvgNode::Type QSvgFeColorMatrix::type() const
+{
+    return QSvgNode::FeColormatrix;
+}
+
+QImage QSvgFeColorMatrix::apply(QSvgNode *item, const QMap<QString, QImage> &sources, QPainter *p,
+                                const QRectF &itemBounds, const QRectF &filterBounds,
+                                QtSvg::UnitTypes primitiveUnits, QtSvg::UnitTypes filterUnits) const
+{
+    if (!sources.contains(m_input))
+        return QImage();
+    QImage source = sources[m_input];
+
+    QRect clipRectGlob = globalFilterBoundingBox(item, p, itemBounds, filterBounds, primitiveUnits, filterUnits).toRect();
+    QRect requiredRect = p->transform().mapRect(itemBounds).toRect();
+    clipRectGlob = clipRectGlob.intersected(requiredRect);
+    if (clipRectGlob.isEmpty())
+        return QImage();
+
+    QImage result;
+    if (!QImageIOHandler::allocateImage(clipRectGlob.size(), QImage::Format_RGBA8888, &result)) {
+        qCWarning(lcSvgDraw) << "The requested filter buffer is too big, ignoring";
+        return QImage();
+    }
+    result.setOffset(clipRectGlob.topLeft());
+    result.fill(Qt::transparent);
+
+    Q_ASSERT(source.depth() == 32);
+
+    for (int i = 0; i < result.height(); i++) {
+        int sourceI = i - source.offset().y() + result.offset().y();
+
+        if (sourceI < 0 || sourceI >= source.height())
+            continue;
+
+        QRgb *sourceLine = reinterpret_cast<QRgb *>(source.scanLine(sourceI));
+        QRgb *resultLine = reinterpret_cast<QRgb *>(result.scanLine(i));
+
+        for (int j = 0; j < result.width(); j++) {
+            int sourceJ = j - source.offset().x() + result.offset().x();
+
+            if (sourceJ < 0 || sourceJ >= source.width())
+                continue;
+
+            qreal a = qAlpha(sourceLine[sourceJ]);
+            qreal r = qBlue(sourceLine[sourceJ]);
+            qreal g = qGreen(sourceLine[sourceJ]);
+            qreal b = qRed(sourceLine[sourceJ]);
+
+            qreal r2 = m_matrix.data()[0+0*5] * r +
+                       m_matrix.data()[1+0*5] * g +
+                       m_matrix.data()[2+0*5] * b +
+                       m_matrix.data()[3+0*5] * a +
+                       m_matrix.data()[4+0*5] * 255.;
+            qreal g2 = m_matrix.data()[0+1*5] * r +
+                       m_matrix.data()[1+1*5] * g +
+                       m_matrix.data()[2+1*5] * b +
+                       m_matrix.data()[3+1*5] * a +
+                       m_matrix.data()[4+1*5] * 255.;
+            qreal b2 = m_matrix.data()[0+2*5] * r +
+                       m_matrix.data()[1+2*5] * g +
+                       m_matrix.data()[2+2*5] * b +
+                       m_matrix.data()[3+2*5] * a +
+                       m_matrix.data()[4+2*5] * 255.;
+            qreal a2 = m_matrix.data()[0+3*5] * r +
+                       m_matrix.data()[1+3*5] * g +
+                       m_matrix.data()[2+3*5] * b +
+                       m_matrix.data()[3+3*5] * a +
+                       m_matrix.data()[4+3*5] * 255.;
+
+            resultLine[j] = qRgba(qBound(0, int(b2), 255),
+                                  qBound(0, int(g2), 255),
+                                  qBound(0, int(r2), 255),
+                                  qBound(0, int(a2), 255));
+        }
+    }
+
+    clipToTransformedBounds(&result, p, localFilterBoundingBox(item, itemBounds, filterBounds, primitiveUnits, filterUnits));
+    return result;
+}
+
+QSvgFeGaussianBlur::QSvgFeGaussianBlur(QSvgNode *parent, QString input, QString result, const QSvgRectF &rect,
+                                       qreal stdDeviationX, qreal stdDeviationY, EdgeMode edgemode)
+    : QSvgFeFilterPrimitive(parent, input, result, rect)
+    , m_stdDeviationX(stdDeviationX)
+    , m_stdDeviationY(stdDeviationY)
+    , m_edgemode(edgemode)
+{
+    (void)m_edgemode;
+}
+
+QSvgNode::Type QSvgFeGaussianBlur::type() const
+{
+    return QSvgNode::FeGaussianblur;
+}
+
+QImage QSvgFeGaussianBlur::apply(QSvgNode *item, const QMap<QString, QImage> &sources, QPainter *p,
+                                 const QRectF &itemBounds, const QRectF &filterBounds,
+                                 QtSvg::UnitTypes primitiveUnits, QtSvg::UnitTypes filterUnits) const
+{
+    if (!sources.contains(m_input))
+        return QImage();
+    QImage source = sources[m_input];
+    Q_ASSERT(source.depth() == 32);
+
+    QPointF sigma_scaled = p->transform().map(QPointF(m_stdDeviationX, m_stdDeviationY)) -
+            p->transform().map(QPointF(0, 0));
+    qreal sigma_x = sigma_scaled.x();
+    qreal sigma_y = sigma_scaled.y();
+    if (primitiveUnits == QtSvg::UnitTypes::objectBoundingBox) {
+        sigma_x *= itemBounds.width();
+        sigma_y *= itemBounds.height();
+    }
+
+    // TODO: if p->transform contains anything other than translate and scale,
+    //       then the gaussian filter has to be applied in local coordinates
+    //       and the resulting image has to be transformed into global
+    //       coordinates
+
+    int dx = qMax(1, int(floor(sigma_x * 3. * sqrt(2. * M_PI) / 4. + 0.5)));
+    int dy = qMax(1, int(floor(sigma_y * 3. * sqrt(2. * M_PI) / 4. + 0.5)));
+
+    QRect clipRectGlob = globalFilterBoundingBox(item, p, itemBounds, filterBounds, primitiveUnits, filterUnits).toRect();
+    QRect requiredRect = p->transform().mapRect(itemBounds).toRect();
+    requiredRect.adjust(- 3 * dx, -3 * dy, 3 * dx, 3 * dy);
+    clipRectGlob = clipRectGlob.intersected(requiredRect);
+    if (clipRectGlob.isEmpty())
+        return QImage();
+
+    QImage tempSource;
+    if (!QImageIOHandler::allocateImage(clipRectGlob.size(), QImage::Format_RGBA8888_Premultiplied, &tempSource)) {
+        qCWarning(lcSvgDraw) << "The requested filter buffer is too big, ignoring";
+        return QImage();
+    }
+    tempSource.setOffset(clipRectGlob.topLeft());
+    tempSource.fill(Qt::transparent);
+    QPainter copyPainter(&tempSource);
+    copyPainter.drawImage(source.offset() - clipRectGlob.topLeft(), source);
+    copyPainter.end();
+
+    QImage result = tempSource;
+
+    // Using the approximation of a boxblur applied 3 times. Decoupling vertical and horizontal
+    for (int m = 0; m < 6; m++) {
+        QRgb *rawSource = reinterpret_cast<QRgb *>(tempSource.bits());
+        QRgb *rawResult = reinterpret_cast<QRgb *>(result.bits());
+
+        int d = (m % 2 == 0) ? dx : dy;
+        int maxdim = (m % 2 == 0) ? tempSource.width() : tempSource.height();
+
+        if (d < 1)
+            continue;
+
+        for (int i = 0; i < tempSource.width(); i++) {
+            for (int j = 0; j < tempSource.height(); j++) {
+
+                int iipos = (m % 2 == 0) ? i : j;
+
+                QVector4D val(0, 0, 0, 0);
+                for (int k = 0; k < d; k++) {
+                    int ii = iipos + k - d / 2;
+                    if (ii < 0 || ii >= maxdim)
+                        continue;
+                    QRgb rgbVal = (m % 2 == 0) ? rawSource[ii + j * tempSource.width()] : rawSource[i + ii * tempSource.width()];
+                    val += QVector4D(qBlue(rgbVal), //TODO: Why are values switched here???
+                                     qGreen(rgbVal),
+                                     qRed(rgbVal), //TODO: Why are values switched here???
+                                     qAlpha(rgbVal)) / d;
+                }
+                rawResult[i + j * tempSource.width()] = qRgba(qBound(0, int(val[0]), 255),
+                                                              qBound(0, int(val[1]), 255),
+                                                              qBound(0, int(val[2]), 255),
+                                                              qBound(0, int(val[3]), 255));
+            }
+        }
+        tempSource = result;
+    }
+
+    clipToTransformedBounds(&result, p, localFilterBoundingBox(item, itemBounds, filterBounds, primitiveUnits, filterUnits));
+    return result;
+}
+
+QSvgFeOffset::QSvgFeOffset(QSvgNode *parent, QString input, QString result, const QSvgRectF &rect,
+                           qreal dx, qreal dy)
+    : QSvgFeFilterPrimitive(parent, input, result, rect)
+    , m_dx(dx)
+    , m_dy(dy)
+{
+
+}
+
+QSvgNode::Type QSvgFeOffset::type() const
+{
+    return QSvgNode::FeOffset;
+}
+
+QImage QSvgFeOffset::apply(QSvgNode *item, const QMap<QString, QImage> &sources, QPainter *p,
+                           const QRectF &itemBounds, const QRectF &filterBounds,
+                           QtSvg::UnitTypes primitiveUnits, QtSvg::UnitTypes filterUnits) const
+{
+    if (!sources.contains(m_input))
+        return QImage();
+
+    const QImage &source = sources[m_input];
+
+    QRectF clipRect = localFilterBoundingBox(item, itemBounds, filterBounds, primitiveUnits, filterUnits);
+    QRect clipRectGlob = p->transform().mapRect(clipRect).toRect();
+
+    QPoint offset(m_dx, m_dy);
+    if (primitiveUnits == QtSvg::UnitTypes::objectBoundingBox) {
+        offset = QPoint(m_dx * itemBounds.width(),
+                        m_dy * itemBounds.height());
+    }
+    offset = p->transform().map(offset) - p->transform().map(QPoint(0, 0));
+
+    QRect requiredRect = QRect(source.offset(), source.size()).translated(offset);
+    clipRectGlob = clipRectGlob.intersected(requiredRect);
+
+    if (clipRectGlob.isEmpty())
+        return QImage();
+
+    QImage result;
+    if (!QImageIOHandler::allocateImage(clipRectGlob.size(), QImage::Format_RGBA8888, &result)) {
+        qCWarning(lcSvgDraw) << "The requested filter buffer is too big, ignoring";
+        return QImage();
+    }
+    result.setOffset(clipRectGlob.topLeft());
+    result.fill(Qt::transparent);
+
+    QPainter copyPainter(&result);
+    copyPainter.drawImage(source.offset()
+                        - result.offset() + offset, source);
+    copyPainter.end();
+
+    clipToTransformedBounds(&result, p, clipRect);
+    return result;
+}
+
+
+QSvgFeMerge::QSvgFeMerge(QSvgNode *parent, QString input, QString result, const QSvgRectF &rect)
+    : QSvgFeFilterPrimitive(parent, input, result, rect)
+{
+
+}
+
+QSvgNode::Type QSvgFeMerge::type() const
+{
+    return QSvgNode::FeMerge;
+}
+
+QImage QSvgFeMerge::apply(QSvgNode *item, const QMap<QString, QImage> &sources, QPainter *p,
+                          const QRectF &itemBounds, const QRectF &filterBounds,
+                          QtSvg::UnitTypes primitiveUnits, QtSvg::UnitTypes filterUnits) const
+{
+    QList<QImage> mergeNodeResults;
+    QRect requiredRect;
+
+    for (int i = 0; i < renderers().size(); i++) {
+        QSvgNode *child = renderers().at(i);
+        if (child->type() == QSvgNode::FeMergenode) {
+            QSvgFeMergeNode *filter = static_cast<QSvgFeMergeNode*>(child);
+            mergeNodeResults.append(filter->apply(item, sources, p, itemBounds, filterBounds, primitiveUnits, filterUnits));
+            requiredRect = requiredRect.united(QRect(mergeNodeResults.last().offset(),
+                                                     mergeNodeResults.last().size()));
+        }
+    }
+
+    QRectF clipRect = localFilterBoundingBox(item, itemBounds, filterBounds, primitiveUnits, filterUnits);
+    QRect clipRectGlob = p->transform().mapRect(clipRect).toRect();
+    clipRectGlob = clipRectGlob.intersected(requiredRect);
+    if (clipRectGlob.isEmpty())
+        return QImage();
+
+    QImage result;
+    if (!QImageIOHandler::allocateImage(clipRectGlob.size(), QImage::Format_RGBA8888, &result)) {
+        qCWarning(lcSvgDraw) << "The requested filter buffer is too big, ignoring";
+        return QImage();
+    }
+    result.setOffset(clipRectGlob.topLeft());
+    result.fill(Qt::transparent);
+
+    QPainter proxyPainter(&result);
+    for (const QImage &i : mergeNodeResults) {
+        proxyPainter.drawImage(QRect(i.offset() - result.offset(), i.size()), i);
+    }
+    proxyPainter.end();
+
+    clipToTransformedBounds(&result, p, clipRect);
+    return result;
+}
+
+bool QSvgFeMerge::requiresSourceAlpha() const
+{
+    for (int i = 0; i < renderers().size(); i++) {
+        QSvgNode *child = renderers().at(i);
+        if (child->type() == QSvgNode::FeMergenode) {
+            QSvgFeMergeNode *filter = static_cast<QSvgFeMergeNode *>(child);
+            if (filter->requiresSourceAlpha())
+                return true;
+        }
+    }
+    return false;
+}
+
+QSvgFeMergeNode::QSvgFeMergeNode(QSvgNode *parent, QString input, QString result, const QSvgRectF &rect)
+    : QSvgFeFilterPrimitive(parent, input, result, rect)
+{
+
+}
+
+QSvgNode::Type QSvgFeMergeNode::type() const
+{
+    return QSvgNode::FeMergenode;
+}
+
+QImage QSvgFeMergeNode::apply(QSvgNode *, const QMap<QString, QImage> &sources, QPainter *,
+                              const QRectF &, const QRectF &, QtSvg::UnitTypes, QtSvg::UnitTypes) const
+{
+    return sources.value(m_input);
+}
+
+QSvgFeComposite::QSvgFeComposite(QSvgNode *parent, QString input, QString result, const QSvgRectF &rect,
+                                 QString input2, Operator op, QVector4D k)
+    : QSvgFeFilterPrimitive(parent, input, result, rect)
+    , m_input2(input2)
+    , m_operator(op)
+    , m_k(k)
+{
+
+}
+
+QSvgNode::Type QSvgFeComposite::type() const
+{
+    return QSvgNode::FeComposite;
+}
+
+QImage QSvgFeComposite::apply(QSvgNode *item, const QMap<QString, QImage> &sources, QPainter *p,
+                              const QRectF &itemBounds, const QRectF &filterBounds,
+                              QtSvg::UnitTypes primitiveUnits, QtSvg::UnitTypes filterUnits) const
+{
+    if (!sources.contains(m_input))
+        return QImage();
+    if (!sources.contains(m_input2))
+        return QImage();
+    QImage source1 = sources[m_input];
+    QImage source2 = sources[m_input2];
+    Q_ASSERT(source1.depth() == 32);
+    Q_ASSERT(source2.depth() == 32);
+
+    QRectF clipRect = localFilterBoundingBox(item, itemBounds, filterBounds, primitiveUnits, filterUnits);
+    QRect clipRectGlob = globalFilterBoundingBox(item, p, itemBounds, filterBounds, primitiveUnits, filterUnits).toRect();
+    QRect requiredRect = QRect(source1.offset(), source1.size()).united(
+                         QRect(source2.offset(), source2.size()));
+    clipRectGlob = clipRectGlob.intersected(requiredRect);
+    if (clipRectGlob.isEmpty())
+        return QImage();
+
+    QImage result;
+    if (!QImageIOHandler::allocateImage(clipRectGlob.size(), QImage::Format_RGBA8888, &result)) {
+        qCWarning(lcSvgDraw) << "The requested filter buffer is too big, ignoring";
+        return QImage();
+    }
+    result.setOffset(clipRectGlob.topLeft());
+    result.fill(Qt::transparent);
+
+    if (m_operator == Operator::Arithmetic) {
+        const qreal k1 = m_k.x();
+        const qreal k2 = m_k.y();
+        const qreal k3 = m_k.z();
+        const qreal k4 = m_k.w();
+
+        for (int j = 0; j < result.height(); j++) {
+            int jj1 = j - source1.offset().y() + result.offset().y();
+            int jj2 = j - source2.offset().y() + result.offset().y();
+
+            QRgb *resultLine = reinterpret_cast<QRgb *>(result.scanLine(j));
+            QRgb *source1Line = nullptr;
+            QRgb *source2Line = nullptr;
+
+            if (jj1 >= 0 && jj1 < source1.size().height())
+                source1Line = reinterpret_cast<QRgb *>(source1.scanLine(jj1));
+            if (jj2 >= 0 && jj2 < source2.size().height())
+                 source2Line = reinterpret_cast<QRgb *>(source2.scanLine(jj2));
+
+            for (int i = 0; i < result.width(); i++) {
+                int ii1 = i - source1.offset().x() + result.offset().x();
+                int ii2 = i - source2.offset().x() + result.offset().x();
+
+                QVector4D s1 = QVector4D(0, 0, 0, 0);
+                QVector4D s2 = QVector4D(0, 0, 0, 0);
+
+                if (ii1 >= 0 && ii1 < source1.size().width() && source1Line) {
+                    QRgb pixel1 = source1Line[ii1];
+                    s1 = QVector4D(qRed(pixel1),
+                                   qGreen(pixel1),
+                                   qBlue(pixel1),
+                                   qAlpha(pixel1));
+                }
+
+                if (ii2 >= 0 && ii2 < source2.size().width() && source2Line) {
+                    QRgb pixel2 = source2Line[ii2];
+                    s2 = QVector4D(qRed(pixel2),
+                                   qGreen(pixel2),
+                                   qBlue(pixel2),
+                                   qAlpha(pixel2));
+                }
+
+                int r = k1 * s1.x() * s2.x() / 255. + k2 * s1.x() + k3 * s2.x() + k4 * 255.;
+                int g = k1 * s1.y() * s2.y() / 255. + k2 * s1.y() + k3 * s2.y() + k4 * 255.;
+                int b = k1 * s1.z() * s2.z() / 255. + k2 * s1.z() + k3 * s2.z() + k4 * 255.;
+                int a = k1 * s1.w() * s2.w() / 255. + k2 * s1.w() + k3 * s2.w() + k4 * 255.;
+
+                qreal alpha = qBound(0, a, 255) / 255.;
+                if (alpha == 0)
+                    alpha = 1;
+                resultLine[i] =  qRgba(qBound(0., r / alpha, 255.),
+                                       qBound(0., g / alpha, 255.),
+                                       qBound(0., b / alpha, 255.),
+                                       qBound(0, a, 255));
+            }
+        }
+    } else {
+        QPainter proxyPainter(&result);
+        proxyPainter.drawImage(QRect(source1.offset() - result.offset(), source1.size()), source1);
+
+        switch (m_operator) {
+        case Operator::In:
+            proxyPainter.setCompositionMode(QPainter::CompositionMode_DestinationIn);
+            break;
+        case Operator::Out:
+            proxyPainter.setCompositionMode(QPainter::CompositionMode_DestinationOut);
+            break;
+        case Operator::Xor:
+            proxyPainter.setCompositionMode(QPainter::CompositionMode_Xor);
+            break;
+        case Operator::Lighter:
+            proxyPainter.setCompositionMode(QPainter::CompositionMode_Lighten);
+            break;
+        case Operator::Atop:
+            proxyPainter.setCompositionMode(QPainter::CompositionMode_DestinationAtop);
+            break;
+        case Operator::Over:
+            proxyPainter.setCompositionMode(QPainter::CompositionMode_DestinationOver);
+            break;
+        case Operator::Arithmetic: // handled above
+            Q_UNREACHABLE();
+            break;
+        }
+        proxyPainter.drawImage(QRect(source2.offset()-result.offset(), source2.size()), source2);
+        proxyPainter.end();
+    }
+
+    clipToTransformedBounds(&result, p, clipRect);
+    return result;
+}
+
+bool QSvgFeComposite::requiresSourceAlpha() const
+{
+    if (QSvgFeFilterPrimitive::requiresSourceAlpha())
+        return true;
+    return m_input2 == QLatin1StringView("SourceAlpha");
+}
+
+
+QSvgFeFlood::QSvgFeFlood(QSvgNode *parent, QString input, QString result,
+                         const QSvgRectF &rect, const QColor &color)
+    : QSvgFeFilterPrimitive(parent, input, result, rect)
+    , m_color(color)
+{
+
+}
+
+QSvgNode::Type QSvgFeFlood::type() const
+{
+    return QSvgNode::FeFlood;
+}
+
+QImage QSvgFeFlood::apply(QSvgNode *item, const QMap<QString, QImage> &,
+                          QPainter *p, const QRectF &itemBounds, const QRectF &filterBounds,
+                          QtSvg::UnitTypes primitiveUnits, QtSvg::UnitTypes filterUnits) const
+{
+
+    QRectF clipRect = localFilterBoundingBox(item, itemBounds, filterBounds, primitiveUnits, filterUnits);
+    QRect clipRectGlob = p->transform().mapRect(clipRect).toRect();
+
+    QImage result;
+    if (!QImageIOHandler::allocateImage(clipRectGlob.size(), QImage::Format_RGBA8888, &result)) {
+        qCWarning(lcSvgDraw) << "The requested filter buffer is too big, ignoring";
+        return QImage();
+    }
+    result.setOffset(clipRectGlob.topLeft());
+    result.fill(m_color);
+
+    clipToTransformedBounds(&result, p, clipRect);
+    return result;
+}
+
+
+QT_END_NAMESPACE
diff --git a/src/svg/qsvgfilter_p.h b/src/svg/qsvgfilter_p.h
new file mode 100644
index 0000000..70c50de
--- /dev/null
+++ b/src/svg/qsvgfilter_p.h
@@ -0,0 +1,185 @@
+// Copyright (C) 2023 The Qt Company Ltd.
+// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
+
+#ifndef QSVGFILTER_P_H
+#define QSVGFILTER_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qsvgnode_p.h"
+#include "qtsvgglobal_p.h"
+#include "qsvgstructure_p.h"
+#include "qgenericmatrix.h"
+
+#include "QtCore/qlist.h"
+#include "QtCore/qhash.h"
+#include "QtGui/qvector4d.h"
+
+QT_BEGIN_NAMESPACE
+
+class Q_SVG_EXPORT QSvgFeFilterPrimitive : public QSvgStructureNode
+{
+public:
+    QSvgFeFilterPrimitive(QSvgNode *parent, QString input, QString result, const QSvgRectF &rect);
+    void drawCommand(QPainter *, QSvgExtraStates &) override {};
+    QRectF fastBounds(QPainter *, QSvgExtraStates &) const override { return QRectF(); }
+    QRectF bounds(QPainter *, QSvgExtraStates &) const override { return QRectF(); }
+    QRectF localFilterBoundingBox(QSvgNode *item,
+                                  const QRectF &itemBounds, const QRectF &filterBounds,
+                                  QtSvg::UnitTypes primitiveUnits, QtSvg::UnitTypes filterUnits) const;
+    QRectF globalFilterBoundingBox(QSvgNode *item, QPainter *p,
+                                   const QRectF &itemBounds, const QRectF &filterBounds,
+                                   QtSvg::UnitTypes primitiveUnits, QtSvg::UnitTypes filterUnits) const;
+    void clipToTransformedBounds(QImage *buffer, QPainter *p, const QRectF &localRect) const;
+    virtual QImage apply(QSvgNode *item, const QMap<QString, QImage> &sources,
+                         QPainter *p, const QRectF &itemBounds, const QRectF &filterBounds,
+                         QtSvg::UnitTypes primitiveUnits, QtSvg::UnitTypes filterUnits) const = 0;
+    virtual bool requiresSourceAlpha() const;
+    QString input() const {
+        return m_input;
+    }
+    QString result() const {
+        return m_result;
+    }
+
+    static const QSvgFeFilterPrimitive *castToFilterPrimitive(const QSvgNode *node);
+
+protected:
+    QString m_input;
+    QString m_result;
+    QSvgRectF m_rect;
+
+
+};
+
+class Q_SVG_EXPORT QSvgFeColorMatrix : public QSvgFeFilterPrimitive
+{
+public:
+    enum class ColorShiftType : quint8 {
+        Matrix,
+        Saturate,
+        HueRotate,
+        LuminanceToAlpha
+    };
+
+    typedef QGenericMatrix<5, 5, qreal> Matrix;
+    typedef QGenericMatrix<5, 1, qreal> Vector;
+
+    QSvgFeColorMatrix(QSvgNode *parent, QString input, QString result, const QSvgRectF &rect,
+                      ColorShiftType type, Matrix matrix);
+    Type type() const override;
+    QImage apply(QSvgNode *item, const QMap<QString, QImage> &sources,
+                 QPainter *p, const QRectF &itemBounds, const QRectF &filterBounds,
+                 QtSvg::UnitTypes primitiveUnits, QtSvg::UnitTypes filterUnits) const override;
+private:
+    ColorShiftType m_type;
+    Matrix m_matrix;
+};
+
+class Q_SVG_EXPORT QSvgFeGaussianBlur : public QSvgFeFilterPrimitive
+{
+public:
+    enum class EdgeMode : quint8 {
+        Duplicate,
+        Wrap,
+        None
+    };
+
+    QSvgFeGaussianBlur(QSvgNode *parent, QString input, QString result, const QSvgRectF &rect,
+                       qreal stdDeviationX, qreal stdDeviationY, EdgeMode edgemode);
+    Type type() const override;
+    QImage apply(QSvgNode *item, const QMap<QString, QImage> &sources,
+                 QPainter *p, const QRectF &itemBounds, const QRectF &filterBounds,
+                 QtSvg::UnitTypes primitiveUnits, QtSvg::UnitTypes filterUnits) const override;
+private:
+    qreal m_stdDeviationX;
+    qreal m_stdDeviationY;
+    EdgeMode m_edgemode;
+};
+
+class Q_SVG_EXPORT QSvgFeOffset : public QSvgFeFilterPrimitive
+{
+public:
+    QSvgFeOffset(QSvgNode *parent, QString input, QString result, const QSvgRectF &rect,
+                 qreal dx, qreal dy);
+    Type type() const override;
+    QImage apply(QSvgNode *item, const QMap<QString, QImage> &sources,
+                 QPainter *p, const QRectF &itemBounds, const QRectF &filterBounds,
+                 QtSvg::UnitTypes primitiveUnits, QtSvg::UnitTypes filterUnits) const override;
+private:
+    qreal m_dx;
+    qreal m_dy;
+};
+
+class Q_SVG_EXPORT QSvgFeMerge : public QSvgFeFilterPrimitive
+{
+public:
+    QSvgFeMerge(QSvgNode *parent, QString input, QString result, const QSvgRectF &rect);
+    Type type() const override;
+    QImage apply(QSvgNode *item, const QMap<QString, QImage> &sources,
+                 QPainter *p, const QRectF &itemBounds, const QRectF &filterBounds,
+                 QtSvg::UnitTypes primitiveUnits, QtSvg::UnitTypes filterUnits) const override;
+    bool requiresSourceAlpha() const override;
+};
+
+class Q_SVG_EXPORT QSvgFeMergeNode : public QSvgFeFilterPrimitive
+{
+public:
+    QSvgFeMergeNode(QSvgNode *parent, QString input, QString result, const QSvgRectF &rect);
+    Type type() const override;
+    QImage apply(QSvgNode *item, const QMap<QString, QImage> &sources,
+                 QPainter *p, const QRectF &itemBounds, const QRectF &filterBounds,
+                 QtSvg::UnitTypes primitiveUnits, QtSvg::UnitTypes filterUnits) const override;
+};
+
+class Q_SVG_EXPORT QSvgFeComposite : public QSvgFeFilterPrimitive
+{
+public:
+    enum class Operator : quint8 {
+        Over,
+        In,
+        Out,
+        Atop,
+        Xor,
+        Lighter,
+        Arithmetic
+    };
+    QSvgFeComposite(QSvgNode *parent, QString input, QString result, const QSvgRectF &rect,
+                    QString input2, Operator op, QVector4D k);
+    Type type() const override;
+    QImage apply(QSvgNode *item, const QMap<QString, QImage> &sources,
+                 QPainter *p, const QRectF &itemBounds, const QRectF &filterBounds,
+                 QtSvg::UnitTypes primitiveUnits, QtSvg::UnitTypes filterUnits) const override;
+    bool requiresSourceAlpha() const override;
+private:
+    QString m_input2;
+    Operator m_operator;
+    QVector4D m_k;
+};
+
+class Q_SVG_EXPORT QSvgFeFlood : public QSvgFeFilterPrimitive
+{
+public:
+    QSvgFeFlood(QSvgNode *parent, QString input, QString result, const QSvgRectF &rect, const QColor &color);
+    Type type() const override;
+    QImage apply(QSvgNode *item, const QMap<QString, QImage> &sources,
+                 QPainter *p, const QRectF &itemBounds, const QRectF &filterBounds,
+                 QtSvg::UnitTypes primitiveUnits, QtSvg::UnitTypes filterUnits) const override;
+private:
+    QColor m_color;
+};
+
+
+
+QT_END_NAMESPACE
+
+#endif // QSVGFILTER_P_H
diff --git a/src/svg/qsvgfont_p.h b/src/svg/qsvgfont_p.h
index 9cf3dfe..b328a84 100644
--- a/src/svg/qsvgfont_p.h
+++ b/src/svg/qsvgfont_p.h
@@ -23,7 +23,7 @@
 
 QT_BEGIN_NAMESPACE
 
-class Q_SVG_PRIVATE_EXPORT QSvgGlyph
+class Q_SVG_EXPORT QSvgGlyph
 {
 public:
     QSvgGlyph(QChar unicode, const QPainterPath &path, qreal horizAdvX);
@@ -35,7 +35,7 @@ public:
 };
 
 
-class Q_SVG_PRIVATE_EXPORT QSvgFont : public QSvgRefCounted
+class Q_SVG_EXPORT QSvgFont : public QSvgRefCounted
 {
 public:
     static constexpr qreal DEFAULT_UNITS_PER_EM = 1000;
diff --git a/src/svg/qsvggraphics.cpp b/src/svg/qsvggraphics.cpp
index 5cb216b..5431a24 100644
--- a/src/svg/qsvggraphics.cpp
+++ b/src/svg/qsvggraphics.cpp
@@ -2,7 +2,7 @@
 // SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
 
 #include "qsvggraphics_p.h"
-
+#include "qsvgstructure_p.h"
 #include "qsvgfont_p.h"
 
 #include <qabstracttextdocumentlayout.h>
@@ -23,38 +23,14 @@
 QT_BEGIN_NAMESPACE
 
 Q_LOGGING_CATEGORY(lcSvgDraw, "qt.svg.draw")
-Q_LOGGING_CATEGORY(lcSvgTiming, "qt.svg.timing")
-
-#define QT_SVG_TIMING_ENTER \
-    QElapsedTimer qtSvgTimer; qtSvgTimer.start();
-
-#define QT_SVG_TIMING_EXIT(TYPE) \
-    if (Q_UNLIKELY(lcSvgTiming().isDebugEnabled())) \
-        qCDebug(lcSvgTiming) << "Drawing" << TYPE << "took" << (qtSvgTimer.nsecsElapsed() / 1000000.0f) << "ms";
-
-#define QT_SVG_DRAW_SHAPE(command)                          \
-    { qreal oldOpacity = p->opacity();                      \
-    QBrush oldBrush = p->brush();                           \
-    QPen oldPen = p->pen();                                 \
-    p->setPen(Qt::NoPen);                                   \
-    p->setOpacity(oldOpacity * states.fillOpacity);         \
-    command;                                                \
-    p->setPen(oldPen);                                      \
-    if (oldPen != Qt::NoPen && oldPen.brush() != Qt::NoBrush && oldPen.widthF() != 0) { \
-        p->setOpacity(oldOpacity * states.strokeOpacity);   \
-        p->setBrush(Qt::NoBrush);                           \
-        command;                                            \
-        p->setBrush(oldBrush);                              \
-    }                                                       \
-    p->setOpacity(oldOpacity); }
 
 #ifndef QT_SVG_MAX_LAYOUT_SIZE
 #define QT_SVG_MAX_LAYOUT_SIZE (qint64(QFIXED_MAX / 2))
 #endif
 
-void QSvgAnimation::draw(QPainter *, QSvgExtraStates &)
+void QSvgAnimation::drawCommand(QPainter *, QSvgExtraStates &)
 {
-    qWarning("<animation> no implemented");
+    qWarning("<animation> not implemented");
 }
 
 static inline QRectF boundsOnStroke(QPainter *p, const QPainterPath &path, qreal width)
@@ -83,35 +59,14 @@ QRectF QSvgEllipse::bounds(QPainter *p, QSvgExtraStates &) const
     return qFuzzyIsNull(sw) ? p->transform().map(path).boundingRect() : boundsOnStroke(p, path, sw);
 }
 
-void QSvgEllipse::draw(QPainter *p, QSvgExtraStates &states)
-{
-    QT_SVG_TIMING_ENTER
-    applyStyle(p, states);
-    if (shouldDrawNode(p, states))
-        QT_SVG_DRAW_SHAPE(p->drawEllipse(m_bounds));
-    revertStyle(p, states);
-    QT_SVG_TIMING_EXIT("Ellipse")
-}
-
-QSvgArc::QSvgArc(QSvgNode *parent, const QPainterPath &path)
-    : QSvgNode(parent), m_path(path)
+void QSvgEllipse::drawCommand(QPainter *p, QSvgExtraStates &)
 {
+    p->drawEllipse(m_bounds);
 }
 
-void QSvgArc::draw(QPainter *p, QSvgExtraStates &states)
+bool QSvgEllipse::separateFillStroke() const
 {
-    QT_SVG_TIMING_ENTER
-    applyStyle(p, states);
-    if (shouldDrawNode(p, states)) {
-        if (p->pen().widthF() != 0) {
-            qreal oldOpacity = p->opacity();
-            p->setOpacity(oldOpacity * states.strokeOpacity);
-            p->drawPath(m_path);
-            p->setOpacity(oldOpacity);
-        }
-    }
-    revertStyle(p, states);
-    QT_SVG_TIMING_EXIT("Arc")
+    return true;
 }
 
 QSvgImage::QSvgImage(QSvgNode *parent, const QImage &image,
@@ -125,38 +80,25 @@ QSvgImage::QSvgImage(QSvgNode *parent, const QImage &image,
         m_bounds.setHeight(static_cast<qreal>(m_image.height()));
 }
 
-void QSvgImage::draw(QPainter *p, QSvgExtraStates &states)
+void QSvgImage::drawCommand(QPainter *p, QSvgExtraStates &)
 {
-    QT_SVG_TIMING_ENTER
-    if (shouldDrawNode(p, states)) {
-        applyStyle(p, states);
-        p->drawImage(m_bounds, m_image);
-        revertStyle(p, states);
-    }
-    QT_SVG_TIMING_EXIT("Image")
+    p->drawImage(m_bounds, m_image);
 }
 
-
 QSvgLine::QSvgLine(QSvgNode *parent, const QLineF &line)
     : QSvgNode(parent), m_line(line)
 {
 }
 
-
-void QSvgLine::draw(QPainter *p, QSvgExtraStates &states)
+void QSvgLine::drawCommand(QPainter *p, QSvgExtraStates &states)
 {
-    QT_SVG_TIMING_ENTER
-    applyStyle(p, states);
-    if (shouldDrawNode(p, states)) {
-        if (p->pen().widthF() != 0) {
-            qreal oldOpacity = p->opacity();
-            p->setOpacity(oldOpacity * states.strokeOpacity);
-            p->drawLine(m_line);
-            p->setOpacity(oldOpacity);
-        }
+    if (p->pen().widthF() != 0) {
+        qreal oldOpacity = p->opacity();
+        p->setOpacity(oldOpacity * states.strokeOpacity);
+        p->drawLine(m_line);
+        p->setOpacity(oldOpacity);
     }
-    revertStyle(p, states);
-    QT_SVG_TIMING_EXIT("Line")
+    QSvgMarker::drawMarkersForNode(this, p, states);
 }
 
 QSvgPath::QSvgPath(QSvgNode *parent, const QPainterPath &qpath)
@@ -164,16 +106,16 @@ QSvgPath::QSvgPath(QSvgNode *parent, const QPainterPath &qpath)
 {
 }
 
-void QSvgPath::draw(QPainter *p, QSvgExtraStates &states)
+void QSvgPath::drawCommand(QPainter *p, QSvgExtraStates &states)
 {
-    QT_SVG_TIMING_ENTER
-    applyStyle(p, states);
-    if (shouldDrawNode(p, states)) {
-        m_path.setFillRule(states.fillRule);
-        QT_SVG_DRAW_SHAPE(p->drawPath(m_path));
-    }
-    revertStyle(p, states);
-    QT_SVG_TIMING_EXIT("Path")
+    m_path.setFillRule(states.fillRule);
+    p->drawPath(m_path);
+    QSvgMarker::drawMarkersForNode(this, p, states);
+}
+
+bool QSvgPath::separateFillStroke() const
+{
+    return true;
 }
 
 QRectF QSvgPath::fastBounds(QPainter *p, QSvgExtraStates &) const
@@ -210,16 +152,16 @@ QRectF QSvgPolygon::bounds(QPainter *p, QSvgExtraStates &) const
     }
 }
 
-void QSvgPolygon::draw(QPainter *p, QSvgExtraStates &states)
+void QSvgPolygon::drawCommand(QPainter *p, QSvgExtraStates &states)
 {
-    QT_SVG_TIMING_ENTER
-    applyStyle(p, states);
-    if (shouldDrawNode(p, states))
-        QT_SVG_DRAW_SHAPE(p->drawPolygon(m_poly, states.fillRule));
-    revertStyle(p, states);
-    QT_SVG_TIMING_EXIT("Polygon")
+    p->drawPolygon(m_poly, states.fillRule);
+    QSvgMarker::drawMarkersForNode(this, p, states);
 }
 
+bool QSvgPolygon::separateFillStroke() const
+{
+    return true;
+}
 
 QSvgPolyline::QSvgPolyline(QSvgNode *parent, const QPolygonF &poly)
     : QSvgNode(parent), m_poly(poly)
@@ -227,30 +169,22 @@ QSvgPolyline::QSvgPolyline(QSvgNode *parent, const QPolygonF &poly)
 
 }
 
-void QSvgPolyline::draw(QPainter *p, QSvgExtraStates &states)
+void QSvgPolyline::drawCommand(QPainter *p, QSvgExtraStates &states)
 {
-    QT_SVG_TIMING_ENTER
-    applyStyle(p, states);
-    if (shouldDrawNode(p, states)) {
-        qreal oldOpacity = p->opacity();
-        if (p->brush().style() != Qt::NoBrush) {
-            QPen save = p->pen();
-            p->setPen(QPen(Qt::NoPen));
-            p->setOpacity(oldOpacity * states.fillOpacity);
-            p->drawPolygon(m_poly, states.fillRule);
-            p->setPen(save);
-        }
-        if (p->pen().widthF() != 0) {
-            p->setOpacity(oldOpacity * states.strokeOpacity);
-            p->drawPolyline(m_poly);
-        }
-        p->setOpacity(oldOpacity);
+    if (p->brush().style() != Qt::NoBrush) {
+        p->drawPolygon(m_poly, states.fillRule);
+    } else {
+        p->drawPolyline(m_poly);
+        QSvgMarker::drawMarkersForNode(this, p, states);
     }
-    revertStyle(p, states);
-    QT_SVG_TIMING_EXIT("Polyline")
 }
 
-QSvgRect::QSvgRect(QSvgNode *node, const QRectF &rect, int rx, int ry)
+bool QSvgPolyline::separateFillStroke() const
+{
+    return true;
+}
+
+QSvgRect::QSvgRect(QSvgNode *node, const QRectF &rect, qreal rx, qreal ry)
     : QSvgNode(node),
       m_rect(rect), m_rx(rx), m_ry(ry)
 {
@@ -273,19 +207,17 @@ QRectF QSvgRect::bounds(QPainter *p, QSvgExtraStates &) const
     }
 }
 
-void QSvgRect::draw(QPainter *p, QSvgExtraStates &states)
+void QSvgRect::drawCommand(QPainter *p, QSvgExtraStates &)
 {
-    QT_SVG_TIMING_ENTER
-    applyStyle(p, states);
-    if (shouldDrawNode(p, states)) {
-        if (m_rx || m_ry) {
-            QT_SVG_DRAW_SHAPE(p->drawRoundedRect(m_rect, m_rx, m_ry, Qt::RelativeSize));
-        } else {
-            QT_SVG_DRAW_SHAPE(p->drawRect(m_rect));
-        }
-    }
-    revertStyle(p, states);
-    QT_SVG_TIMING_EXIT("Rect")
+    if (m_rx || m_ry)
+        p->drawRoundedRect(m_rect, m_rx, m_ry, Qt::RelativeSize);
+    else
+        p->drawRect(m_rect);
+}
+
+bool QSvgRect::separateFillStroke() const
+{
+    return true;
 }
 
 QSvgTspan * const QSvgText::LINEBREAK = 0;
@@ -293,7 +225,7 @@ QSvgTspan * const QSvgText::LINEBREAK = 0;
 QSvgText::QSvgText(QSvgNode *parent, const QPointF &coord)
     : QSvgNode(parent)
     , m_coord(coord)
-    , m_type(TEXT)
+    , m_type(Text)
     , m_size(0, 0)
     , m_mode(Default)
 {
@@ -310,12 +242,12 @@ QSvgText::~QSvgText()
 void QSvgText::setTextArea(const QSizeF &size)
 {
     m_size = size;
-    m_type = TEXTAREA;
+    m_type = Textarea;
 }
 
 QRectF QSvgText::fastBounds(QPainter *p, QSvgExtraStates &) const
 {
-    QFont font = p->font();
+    QFont font = m_style.font ? m_style.font->qfont() : p->font();
     QFontMetricsF fm(font);
 
     int charCount = 0;
@@ -327,19 +259,24 @@ QRectF QSvgText::fastBounds(QPainter *p, QSvgExtraStates &) const
     QRectF approxMaximumBrect(m_coord.x(),
                               m_coord.y(),
                               charCount * fm.averageCharWidth(),
-                              m_tspans.size() * fm.height());
+                              -m_tspans.size() * fm.height());
     return p->transform().mapRect(approxMaximumBrect);
 }
 
 QRectF QSvgText::bounds(QPainter *p, QSvgExtraStates &states) const
 {
     QRectF boundingRect;
-    if (precheck(p))
+    if (shouldDrawNode(p, states))
         draw_helper(p, states, &boundingRect);
     return p->transform().mapRect(boundingRect);
 }
 
-bool QSvgText::precheck(QPainter *p) const
+void QSvgText::drawCommand(QPainter *p, QSvgExtraStates &states)
+{
+    draw_helper(p, states);
+}
+
+bool QSvgText::shouldDrawNode(QPainter *p, QSvgExtraStates &) const
 {
     qsizetype numChars = 0;
     qreal originalFontSize = p->font().pointSizeF();
@@ -371,26 +308,17 @@ bool QSvgText::precheck(QPainter *p) const
     return true;
 }
 
-void QSvgText::draw(QPainter *p, QSvgExtraStates &states)
-{
-    QT_SVG_TIMING_ENTER
-    if (precheck(p))
-        draw_helper(p, states);
-    QT_SVG_TIMING_EXIT("Text")
-}
-
 void QSvgText::draw_helper(QPainter *p, QSvgExtraStates &states, QRectF *boundingRect) const
 {
     const bool isPainting = (boundingRect == nullptr);
-    if (isPainting)
-        applyStyle(p, states);
     if (!isPainting || shouldDrawNode(p, states)) {
         qreal oldOpacity = p->opacity();
         p->setOpacity(oldOpacity * states.fillOpacity);
 
         // Force the font to have a size of 100 pixels to avoid truncation problems
         // when the font is very small.
-        qreal scale = 100.0 / p->font().pointSizeF();
+        QFont font = p->font();
+        qreal scale = 100.0 / font.pointSizeF();
         Qt::Alignment alignment = states.textAnchor;
 
         QTransform oldTransform = p->worldTransform();
@@ -402,7 +330,7 @@ void QSvgText::draw_helper(QPainter *p, QSvgExtraStates &states, QRectF *boundin
         qreal py = m_coord.y() * scale;
         QSizeF scaledSize = m_size * scale;
 
-        if (m_type == TEXTAREA) {
+        if (m_type == Textarea) {
             if (alignment == Qt::AlignHCenter)
                 px += scaledSize.width() / 2;
             else if (alignment == Qt::AlignRight)
@@ -420,9 +348,8 @@ void QSvgText::draw_helper(QPainter *p, QSvgExtraStates &states, QRectF *boundin
 
         for (int i = 0; i < m_tspans.size(); ++i) {
             if (m_tspans[i] == LINEBREAK) {
-                if (m_type == TEXTAREA) {
+                if (m_type == Textarea) {
                     if (paragraphs.back().isEmpty()) {
-                        QFont font = p->font();
                         font.setPixelSize(font.pointSizeF() * scale);
 
                         QTextLayout::FormatRange range;
@@ -441,7 +368,7 @@ void QSvgText::draw_helper(QPainter *p, QSvgExtraStates &states, QRectF *boundin
                 WhitespaceMode mode = m_tspans[i]->whitespaceMode();
                 m_tspans[i]->applyStyle(p, states);
 
-                QFont font = p->font();
+                font = p->font();
                 font.setPixelSize(font.pointSizeF() * scale);
 
                 QString newText(m_tspans[i]->text());
@@ -520,7 +447,7 @@ void QSvgText::draw_helper(QPainter *p, QSvgExtraStates &states, QRectF *boundin
                     else if (alignment == Qt::AlignRight)
                         x -= line.naturalTextWidth();
 
-                    if (initial && m_type == TEXT)
+                    if (initial && m_type == Text)
                         y -= line.ascent();
                     initial = false;
 
@@ -556,8 +483,6 @@ void QSvgText::draw_helper(QPainter *p, QSvgExtraStates &states, QRectF *boundin
         p->setWorldTransform(oldTransform, false);
         p->setOpacity(oldOpacity);
     }
-    if (isPainting)
-        revertStyle(p, states);
 }
 
 void QSvgText::addText(const QString &text)
@@ -573,9 +498,8 @@ QSvgUse::QSvgUse(const QPointF &start, QSvgNode *parent, QSvgNode *node)
 
 }
 
-void QSvgUse::draw(QPainter *p, QSvgExtraStates &states)
+void QSvgUse::drawCommand(QPainter *p, QSvgExtraStates &states)
 {
-    QT_SVG_TIMING_ENTER
     if (Q_UNLIKELY(!m_link || isDescendantOf(m_link) || m_recursing))
         return;
 
@@ -585,7 +509,7 @@ void QSvgUse::draw(QPainter *p, QSvgExtraStates &states)
         return;
     }
 
-    applyStyle(p, states);
+    QScopedValueRollback<bool> inUseGuard(states.inUse, true);
 
     if (!m_start.isNull()) {
         p->translate(m_start);
@@ -603,66 +527,51 @@ void QSvgUse::draw(QPainter *p, QSvgExtraStates &states)
     if (!m_start.isNull()) {
         p->translate(-m_start);
     }
-
-    revertStyle(p, states);
-    QT_SVG_TIMING_EXIT("Use")
-}
-
-void QSvgVideo::draw(QPainter *p, QSvgExtraStates &states)
-{
-    applyStyle(p, states);
-
-    revertStyle(p, states);
 }
 
 QSvgNode::Type QSvgAnimation::type() const
 {
-    return ANIMATION;
-}
-
-QSvgNode::Type QSvgArc::type() const
-{
-    return ARC;
+    return Animation;
 }
 
 QSvgNode::Type QSvgCircle::type() const
 {
-    return CIRCLE;
+    return Circle;
 }
 
 QSvgNode::Type QSvgEllipse::type() const
 {
-    return ELLIPSE;
+    return Ellipse;
 }
 
 QSvgNode::Type QSvgImage::type() const
 {
-    return IMAGE;
+    return Image;
 }
 
 QSvgNode::Type QSvgLine::type() const
 {
-    return LINE;
+    return Line;
 }
 
 QSvgNode::Type QSvgPath::type() const
 {
-    return PATH;
+    return Path;
 }
 
 QSvgNode::Type QSvgPolygon::type() const
 {
-    return POLYGON;
+    return Polygon;
 }
 
 QSvgNode::Type QSvgPolyline::type() const
 {
-    return POLYLINE;
+    return Polyline;
 }
 
 QSvgNode::Type QSvgRect::type() const
 {
-    return RECT;
+    return Rect;
 }
 
 QSvgNode::Type QSvgText::type() const
@@ -672,12 +581,12 @@ QSvgNode::Type QSvgText::type() const
 
 QSvgNode::Type QSvgUse::type() const
 {
-    return USE;
+    return Use;
 }
 
 QSvgNode::Type QSvgVideo::type() const
 {
-    return VIDEO;
+    return Video;
 }
 
 QRectF QSvgUse::bounds(QPainter *p, QSvgExtraStates &states) const
@@ -709,18 +618,6 @@ QRectF QSvgPolyline::bounds(QPainter *p, QSvgExtraStates &) const
     }
 }
 
-QRectF QSvgArc::fastBounds(QPainter *p, QSvgExtraStates &) const
-{
-    return p->transform().mapRect(m_path.controlPointRect());
-}
-
-QRectF QSvgArc::bounds(QPainter *p, QSvgExtraStates &) const
-{
-    qreal sw = strokeWidth(p);
-    return qFuzzyIsNull(sw) ? p->transform().map(m_path).boundingRect()
-        : boundsOnStroke(p, m_path, sw);
-}
-
 QRectF QSvgImage::bounds(QPainter *p, QSvgExtraStates &) const
 {
     return p->transform().mapRect(m_bounds);
diff --git a/src/svg/qsvggraphics_p.h b/src/svg/qsvggraphics_p.h
index 9bb005b..ad62cc8 100644
--- a/src/svg/qsvggraphics_p.h
+++ b/src/svg/qsvggraphics_p.h
@@ -28,125 +28,124 @@ QT_BEGIN_NAMESPACE
 
 class QTextCharFormat;
 
-class Q_SVG_PRIVATE_EXPORT QSvgAnimation : public QSvgNode
+class Q_SVG_EXPORT QSvgAnimation : public QSvgNode
 {
 public:
-    void draw(QPainter *p, QSvgExtraStates &states) override;
+    void drawCommand(QPainter *, QSvgExtraStates &) override;
     Type type() const override;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgArc : public QSvgNode
-{
-public:
-    QSvgArc(QSvgNode *parent, const QPainterPath &path);
-    void draw(QPainter *p, QSvgExtraStates &states) override;
-    Type type() const override;
-    QRectF fastBounds(QPainter *p, QSvgExtraStates &states) const override;
-    QRectF bounds(QPainter *p, QSvgExtraStates &states) const override;
-private:
-    QPainterPath m_path;
-};
-
-class Q_SVG_PRIVATE_EXPORT QSvgEllipse : public QSvgNode
+class Q_SVG_EXPORT QSvgEllipse : public QSvgNode
 {
 public:
     QSvgEllipse(QSvgNode *parent, const QRectF &rect);
-    void draw(QPainter *p, QSvgExtraStates &states) override;
+    bool separateFillStroke() const override;
+    void drawCommand(QPainter *p, QSvgExtraStates &states) override;
     Type type() const override;
     QRectF fastBounds(QPainter *p, QSvgExtraStates &states) const override;
     QRectF bounds(QPainter *p, QSvgExtraStates &states) const override;
+    QRectF rect() const { return m_bounds; }
 private:
     QRectF m_bounds;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgCircle : public QSvgEllipse
+class Q_SVG_EXPORT QSvgCircle : public QSvgEllipse
 {
 public:
     QSvgCircle(QSvgNode *parent, const QRectF &rect) : QSvgEllipse(parent, rect) { }
     Type type() const override;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgImage : public QSvgNode
+class Q_SVG_EXPORT QSvgImage : public QSvgNode
 {
 public:
     QSvgImage(QSvgNode *parent, const QImage &image,
               const QRectF &bounds);
-    void draw(QPainter *p, QSvgExtraStates &states) override;
+    void drawCommand(QPainter *p, QSvgExtraStates &states) override;
     Type type() const override;
     QRectF bounds(QPainter *p, QSvgExtraStates &states) const override;
+
+    QRectF rect() const { return m_bounds; }
+    const QImage &image() const { return m_image; }
 private:
     QImage m_image;
     QRectF m_bounds;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgLine : public QSvgNode
+class Q_SVG_EXPORT QSvgLine : public QSvgNode
 {
 public:
     QSvgLine(QSvgNode *parent, const QLineF &line);
-    void draw(QPainter *p, QSvgExtraStates &states) override;
+    void drawCommand(QPainter *p, QSvgExtraStates &states) override;
     Type type() const override;
     QRectF fastBounds(QPainter *p, QSvgExtraStates &states) const override;
     QRectF bounds(QPainter *p, QSvgExtraStates &states) const override;
+    QLineF line() const { return m_line; }
 private:
     QLineF m_line;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgPath : public QSvgNode
+class Q_SVG_EXPORT QSvgPath : public QSvgNode
 {
 public:
     QSvgPath(QSvgNode *parent, const QPainterPath &qpath);
-    void draw(QPainter *p, QSvgExtraStates &states) override;
+    bool separateFillStroke() const override;
+    void drawCommand(QPainter *p, QSvgExtraStates &states) override;
     Type type() const override;
     QRectF fastBounds(QPainter *p, QSvgExtraStates &states) const override;
     QRectF bounds(QPainter *p, QSvgExtraStates &states) const override;
-
-    QPainterPath *qpath() {
-        return &m_path;
-    }
+    const QPainterPath &path() const { return m_path; }
 private:
     QPainterPath m_path;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgPolygon : public QSvgNode
+class Q_SVG_EXPORT QSvgPolygon : public QSvgNode
 {
 public:
     QSvgPolygon(QSvgNode *parent, const QPolygonF &poly);
-    void draw(QPainter *p, QSvgExtraStates &states) override;
+    bool separateFillStroke() const override;
+    void drawCommand(QPainter *p, QSvgExtraStates &states) override;
     Type type() const override;
     QRectF fastBounds(QPainter *p, QSvgExtraStates &states) const override;
     QRectF bounds(QPainter *p, QSvgExtraStates &states) const override;
+    const QPolygonF &polygon() const { return m_poly; }
 private:
     QPolygonF m_poly;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgPolyline : public QSvgNode
+class Q_SVG_EXPORT QSvgPolyline : public QSvgNode
 {
 public:
     QSvgPolyline(QSvgNode *parent, const QPolygonF &poly);
-    void draw(QPainter *p, QSvgExtraStates &states) override;
+    bool separateFillStroke() const override;
+    void drawCommand(QPainter *p, QSvgExtraStates &states) override;
     Type type() const override;
     QRectF fastBounds(QPainter *p, QSvgExtraStates &states) const override;
     QRectF bounds(QPainter *p, QSvgExtraStates &states) const override;
+    const QPolygonF &polygon() const { return m_poly; }
 private:
     QPolygonF m_poly;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgRect : public QSvgNode
+class Q_SVG_EXPORT QSvgRect : public QSvgNode
 {
 public:
-    QSvgRect(QSvgNode *paren, const QRectF &rect, int rx=0, int ry=0);
+    QSvgRect(QSvgNode *paren, const QRectF &rect, qreal rx=0, qreal ry=0);
     Type type() const override;
-    void draw(QPainter *p, QSvgExtraStates &states) override;
+    bool separateFillStroke() const override;
+    void drawCommand(QPainter *p, QSvgExtraStates &states) override;
     QRectF fastBounds(QPainter *p, QSvgExtraStates &states) const override;
     QRectF bounds(QPainter *p, QSvgExtraStates &states) const override;
+    QRectF rect() const { return m_rect; }
+    QPointF radius() const { return { m_rx, m_ry }; }
 private:
     QRectF m_rect;
-    int m_rx, m_ry;
+    qreal m_rx, m_ry;
 };
 
 class  QSvgTspan;
 
-class Q_SVG_PRIVATE_EXPORT QSvgText : public QSvgNode
+class Q_SVG_EXPORT QSvgText : public QSvgNode
 {
 public:
     enum WhitespaceMode
@@ -159,10 +158,12 @@ public:
     ~QSvgText();
     void setTextArea(const QSizeF &size);
 
-    void draw(QPainter *p, QSvgExtraStates &states) override;
+    void drawCommand(QPainter *p, QSvgExtraStates &states) override;
+    bool shouldDrawNode(QPainter *p, QSvgExtraStates &states) const override;
     Type type() const override;
 
     void addTspan(QSvgTspan *tspan) {m_tspans.append(tspan);}
+    const QList<QSvgTspan *> tspans() const { return m_tspans; }
     void addText(const QString &text);
     void addLineBreak() {m_tspans.append(LINEBREAK);}
     void setWhitespaceMode(WhitespaceMode mode) {m_mode = mode;}
@@ -170,8 +171,11 @@ public:
     QRectF fastBounds(QPainter *p, QSvgExtraStates &states) const override;
     QRectF bounds(QPainter *p, QSvgExtraStates &states) const override;
 
+    QPointF position() const { return m_coord; }
+    QSizeF size() const { return m_size; }
+    WhitespaceMode whitespaceMode() const { return m_mode; }
+
 private:
-    bool precheck(QPainter *p) const;
     void draw_helper(QPainter *p, QSvgExtraStates &states, QRectF *boundingRect = nullptr) const;
 
     static QSvgTspan * const LINEBREAK;
@@ -187,7 +191,7 @@ private:
     WhitespaceMode m_mode;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgTspan : public QSvgNode
+class Q_SVG_EXPORT QSvgTspan : public QSvgNode
 {
 public:
     // tspans are also used to store normal text, so the 'isProperTspan' is used to separate text from tspan.
@@ -196,8 +200,8 @@ public:
     {
     }
     ~QSvgTspan() { };
-    Type type() const override { return TSPAN; }
-    void draw(QPainter *, QSvgExtraStates &) override { Q_ASSERT(!"Tspans should be drawn through QSvgText::draw()."); }
+    Type type() const override { return Tspan; }
+    void drawCommand(QPainter *, QSvgExtraStates &) override { Q_ASSERT(!"Tspans should be drawn through QSvgText::draw()."); }
     void addText(const QString &text) {m_text += text;}
     const QString &text() const {return m_text;}
     bool isTspan() const {return m_isTspan;}
@@ -216,13 +220,15 @@ public:
     QSvgUse(const QPointF &start, QSvgNode *parent, const QString &linkId)
         : QSvgUse(start, parent, nullptr)
     { m_linkId = linkId; }
-    void draw(QPainter *p, QSvgExtraStates &states) override;
+    void drawCommand(QPainter *p, QSvgExtraStates &states) override;
     Type type() const override;
     QRectF bounds(QPainter *p, QSvgExtraStates &states) const override;
     bool isResolved() const { return m_link != nullptr; }
     QString linkId() const { return m_linkId; }
     void setLink(QSvgNode *link) { m_link = link; }
     QSvgNode *link() const { return m_link; }
+    QPointF start() const { return m_start; }
+    bool isRecursing() const { return m_recursing; }
 
 private:
     QSvgNode *m_link;
@@ -234,7 +240,7 @@ private:
 class QSvgVideo : public QSvgNode
 {
 public:
-    void draw(QPainter *p, QSvgExtraStates &states) override;
+    void drawCommand(QPainter *, QSvgExtraStates &) override {};
     Type type() const override;
 };
 
diff --git a/src/svg/qsvghandler.cpp b/src/svg/qsvghandler.cpp
index 335500a..bf906e8 100644
--- a/src/svg/qsvghandler.cpp
+++ b/src/svg/qsvghandler.cpp
@@ -8,6 +8,7 @@
 #include "qsvgtinydocument_p.h"
 #include "qsvgstructure_p.h"
 #include "qsvggraphics_p.h"
+#include "qsvgfilter_p.h"
 #include "qsvgnode_p.h"
 #include "qsvgfont_p.h"
 
@@ -27,6 +28,7 @@
 #include "qtransform.h"
 #include "qvarlengtharray.h"
 #include "private/qmath_p.h"
+#include "qimagereader.h"
 
 #include "float.h"
 #include <cmath>
@@ -142,7 +144,7 @@ bool qsvg_get_hex_rgb(const QChar *str, int len, QRgb *rgb)
 
 // ======== end of qcolor_p duplicate
 
-static bool parsePathDataFast(QStringView data, QPainterPath &path);
+static bool parsePathDataFast(QStringView data, QPainterPath &path, bool limitLength = true);
 
 static inline QString someId(const QXmlStreamAttributes &attributes)
 {
@@ -187,6 +189,12 @@ struct QSvgAttributes
     QStringView stopColor;
     QStringView stopOpacity;
     QStringView imageRendering;
+    QStringView mask;
+    QStringView markerStart;
+    QStringView markerMid;
+    QStringView markerEnd;
+    QStringView filter;
+
 
 #ifndef QT_NO_CSSPARSER
     QList<QSvgCssAttribute> m_cssAttributes;
@@ -235,6 +243,9 @@ QSvgAttributes::QSvgAttributes(const QXmlStreamAttributes &xmlAttributes, QSvgHa
                 fontWeight = value;
             else if (name == QLatin1String("font-variant"))
                 fontVariant = value;
+            else if (name == QLatin1String("filter") &&
+                     !handler->options().testFlag(QtSvg::Tiny12FeaturesOnly))
+                filter = value;
             break;
 
         case 'i':
@@ -244,6 +255,21 @@ QSvgAttributes::QSvgAttributes(const QXmlStreamAttributes &xmlAttributes, QSvgHa
                 imageRendering = value;
             break;
 
+        case 'm':
+            if (name == QLatin1String("mask") &&
+                !handler->options().testFlag(QtSvg::Tiny12FeaturesOnly))
+                mask = value;
+            if (name == QLatin1String("marker-start") &&
+                !handler->options().testFlag(QtSvg::Tiny12FeaturesOnly))
+                markerStart = value;
+            if (name == QLatin1String("marker-mid") &&
+                !handler->options().testFlag(QtSvg::Tiny12FeaturesOnly))
+                markerMid = value;
+            if (name == QLatin1String("marker-end") &&
+                !handler->options().testFlag(QtSvg::Tiny12FeaturesOnly))
+                markerEnd = value;
+            break;
+
         case 'o':
             if (name == QLatin1String("opacity"))
                 opacity = value;
@@ -346,12 +372,31 @@ QSvgAttributes::QSvgAttributes(const QXmlStreamAttributes &xmlAttributes, QSvgHa
                     fontWeight = value;
                 else if (name == QLatin1String("font-variant"))
                     fontVariant = value;
+                else if (name == QLatin1String("filter") &&
+                         !handler->options().testFlag(QtSvg::Tiny12FeaturesOnly))
+                    filter = value;
                 break;
+
             case 'i':
                 if (name == QLatin1String("image-rendering"))
                     imageRendering = value;
                 break;
 
+            case 'm':
+                if (name == QLatin1String("mask") &&
+                    !handler->options().testFlag(QtSvg::Tiny12FeaturesOnly))
+                    mask = value;
+                if (name == QLatin1String("marker-start") &&
+                    !handler->options().testFlag(QtSvg::Tiny12FeaturesOnly))
+                    markerStart = value;
+                if (name == QLatin1String("marker-mid") &&
+                    !handler->options().testFlag(QtSvg::Tiny12FeaturesOnly))
+                    markerMid = value;
+                if (name == QLatin1String("marker-end") &&
+                    !handler->options().testFlag(QtSvg::Tiny12FeaturesOnly))
+                    markerEnd = value;
+                break;
+
             case 'o':
                 if (name == QLatin1String("opacity"))
                     opacity = value;
@@ -410,28 +455,6 @@ QSvgAttributes::QSvgAttributes(const QXmlStreamAttributes &xmlAttributes, QSvgHa
 
 #ifndef QT_NO_CSSPARSER
 
-static const char * QSvgStyleSelector_nodeString[] = {
-    "svg",
-    "g",
-    "defs",
-    "switch",
-    "animation",
-    "arc",
-    "circle",
-    "ellipse",
-    "image",
-    "line",
-    "path",
-    "polygon",
-    "polyline",
-    "rect",
-    "text",
-    "textarea",
-    "tspan",
-    "use",
-    "video"
-};
-
 class QSvgStyleSelector : public QCss::StyleSelector
 {
 public:
@@ -445,7 +468,7 @@ public:
 
     inline QString nodeToName(QSvgNode *node) const
     {
-        return QLatin1String(QSvgStyleSelector_nodeString[node->type()]);
+        return node->typeName();
     }
 
     inline QSvgNode *svgNode(NodePtr node) const
@@ -455,10 +478,10 @@ public:
     inline QSvgStructureNode *nodeToStructure(QSvgNode *n) const
     {
         if (n &&
-            (n->type() == QSvgNode::DOC ||
-             n->type() == QSvgNode::G ||
-             n->type() == QSvgNode::DEFS ||
-             n->type() == QSvgNode::SWITCH)) {
+            (n->type() == QSvgNode::Doc ||
+             n->type() == QSvgNode::Group ||
+             n->type() == QSvgNode::Defs ||
+             n->type() == QSvgNode::Switch)) {
             return (QSvgStructureNode*)n;
         }
         return 0;
@@ -865,34 +888,40 @@ static bool constructColor(QStringView colorStr, QStringView opacity,
     return true;
 }
 
-static qreal parseLength(QStringView str, QSvgHandler::LengthType &type,
+static qreal parseLength(QStringView str, QSvgHandler::LengthType *type,
                          QSvgHandler *handler, bool *ok = NULL)
 {
     QStringView numStr = str.trimmed();
 
+    if (numStr.isEmpty()) {
+        if (ok)
+            *ok = false;
+        *type = QSvgHandler::LT_OTHER;
+        return false;
+    }
     if (numStr.endsWith(QLatin1Char('%'))) {
         numStr.chop(1);
-        type = QSvgHandler::LT_PERCENT;
+        *type = QSvgHandler::LT_PERCENT;
     } else if (numStr.endsWith(QLatin1String("px"))) {
         numStr.chop(2);
-        type = QSvgHandler::LT_PX;
+        *type = QSvgHandler::LT_PX;
     } else if (numStr.endsWith(QLatin1String("pc"))) {
         numStr.chop(2);
-        type = QSvgHandler::LT_PC;
+        *type = QSvgHandler::LT_PC;
     } else if (numStr.endsWith(QLatin1String("pt"))) {
         numStr.chop(2);
-        type = QSvgHandler::LT_PT;
+        *type = QSvgHandler::LT_PT;
     } else if (numStr.endsWith(QLatin1String("mm"))) {
         numStr.chop(2);
-        type = QSvgHandler::LT_MM;
+        *type = QSvgHandler::LT_MM;
     } else if (numStr.endsWith(QLatin1String("cm"))) {
         numStr.chop(2);
-        type = QSvgHandler::LT_CM;
+        *type = QSvgHandler::LT_CM;
     } else if (numStr.endsWith(QLatin1String("in"))) {
         numStr.chop(2);
-        type = QSvgHandler::LT_IN;
+        *type = QSvgHandler::LT_IN;
     } else {
-        type = handler->defaultCoordinateSystem();
+        *type = handler->defaultCoordinateSystem();
         //type = QSvgHandler::LT_OTHER;
     }
     qreal len = toDouble(numStr, ok);
@@ -903,7 +932,7 @@ static qreal parseLength(QStringView str, QSvgHandler::LengthType &type,
 static inline qreal convertToNumber(QStringView str, QSvgHandler *handler, bool *ok = NULL)
 {
     QSvgHandler::LengthType type;
-    qreal num = parseLength(str.toString(), type, handler, ok);
+    qreal num = parseLength(str.toString(), &type, handler, ok);
     if (type == QSvgHandler::LT_PERCENT) {
         num = num/100.0;
     }
@@ -1001,12 +1030,13 @@ static void parseBrush(QSvgNode *node,
                 QString value = attributes.fill.mid(3, attributes.fill.size() - 3).toString();
                 QSvgStyleProperty *style = styleFromUrl(node, value);
                 if (style) {
-                    if (style->type() == QSvgStyleProperty::SOLID_COLOR || style->type() == QSvgStyleProperty::GRADIENT)
-                        prop->setFillStyle(reinterpret_cast<QSvgFillStyleProperty *>(style));
+                    if (style->type() == QSvgStyleProperty::SOLID_COLOR || style->type() == QSvgStyleProperty::GRADIENT
+                            || style->type() == QSvgStyleProperty::PATTERN)
+                        prop->setFillStyle(reinterpret_cast<QSvgPaintStyleProperty *>(style));
                 } else {
                     QString id = idFromUrl(value);
-                    prop->setGradientId(id);
-                    prop->setGradientResolved(false);
+                    prop->setPaintStyleId(id);
+                    prop->setPaintStyleResolved(false);
                 }
             } else if (attributes.fill != QLatin1String("none")) {
                 QColor color;
@@ -1170,12 +1200,13 @@ static void parsePen(QSvgNode *node,
                  QString value = attributes.stroke.mid(3, attributes.stroke.size() - 3).toString();
                     QSvgStyleProperty *style = styleFromUrl(node, value);
                     if (style) {
-                        if (style->type() == QSvgStyleProperty::SOLID_COLOR || style->type() == QSvgStyleProperty::GRADIENT)
-                            prop->setStyle(reinterpret_cast<QSvgFillStyleProperty *>(style));
+                        if (style->type() == QSvgStyleProperty::SOLID_COLOR || style->type() == QSvgStyleProperty::GRADIENT
+                            || style->type() == QSvgStyleProperty::PATTERN)
+                        prop->setStyle(reinterpret_cast<QSvgPaintStyleProperty *>(style));
                     } else {
                         QString id = idFromUrl(value);
-                        prop->setGradientId(id);
-                        prop->setGradientResolved(false);
+                        prop->setPaintStyleId(id);
+                        prop->setPaintStyleResolved(false);
                     }
             } else if (attributes.stroke != QLatin1String("none")) {
                 QColor color;
@@ -1189,7 +1220,7 @@ static void parsePen(QSvgNode *node,
         //stroke-width handling
         if (!attributes.strokeWidth.isEmpty() && attributes.strokeWidth != QT_INHERIT) {
             QSvgHandler::LengthType lt;
-            prop->setWidth(parseLength(attributes.strokeWidth, lt, handler));
+            prop->setWidth(parseLength(attributes.strokeWidth, &lt, handler));
         }
 
         //stroke-dasharray
@@ -1200,10 +1231,24 @@ static void parsePen(QSvgNode *node,
                 QString dashArray  = attributes.strokeDashArray.toString();
                 const QChar *s = dashArray.constData();
                 QList<qreal> dashes = parseNumbersList(s);
-                // if the dash count is odd the dashes should be duplicated
-                if ((dashes.size() & 1) != 0)
-                    dashes << QList<qreal>(dashes);
-                prop->setDashArray(dashes);
+                bool allZeroes = true;
+                for (qreal dash : dashes) {
+                    if (dash != 0.0) {
+                        allZeroes = false;
+                        break;
+                    }
+                }
+
+                // if the stroke dash array contains only zeros,
+                // force drawing of solid line.
+                if (allZeroes == false) {
+                    // if the dash count is odd the dashes should be duplicated
+                    if ((dashes.size() & 1) != 0)
+                        dashes << QList<qreal>(dashes);
+                    prop->setDashArray(dashes);
+                } else {
+                    prop->setDashArrayNone();
+                }
             }
         }
 
@@ -1326,7 +1371,7 @@ static void parseFont(QSvgNode *node,
             break;
         case FontSizeValue: {
             QSvgHandler::LengthType type;
-            qreal fs = parseLength(attributes.fontSize, type, handler);
+            qreal fs = parseLength(attributes.fontSize, &type, handler);
             fs = convertToPixels(fs, true, type);
             fontStyle->setSize(qMin(fs, qreal(0xffff)));
         }
@@ -1557,7 +1602,7 @@ static void pathArc(QPainterPath &path,
     }
 }
 
-static bool parsePathDataFast(QStringView dataStr, QPainterPath &path)
+static bool parsePathDataFast(QStringView dataStr, QPainterPath &path, bool limitLength)
 {
     const int maxElementCount = 0x7fff; // Assume file corruption if more path elements than this
     qreal x0 = 0, y0 = 0;              // starting point
@@ -1878,7 +1923,7 @@ static bool parsePathDataFast(QStringView dataStr, QPainterPath &path)
                 break;
             }
             lastMode = pathElem.toLatin1();
-            if (path.elementCount() > maxElementCount)
+            if (limitLength && path.elementCount() > maxElementCount)
                 ok = false;
         }
     }
@@ -2036,6 +2081,17 @@ static void cssStyleLookup(QSvgNode *node,
 
 #endif // QT_NO_CSSPARSER
 
+QtSvg::Options QSvgHandler::options() const
+{
+    return m_options;
+}
+
+bool QSvgHandler::trustedSourceMode() const
+{
+    static const bool envAssumeTrusted = qEnvironmentVariableIsSet("QT_SVG_ASSUME_TRUSTED_SOURCE");
+    return envAssumeTrusted;
+}
+
 static inline QStringList stringToList(const QString &str)
 {
     QStringList lst = str.split(QLatin1Char(','), Qt::SkipEmptyParts);
@@ -2238,6 +2294,69 @@ static void parseOthers(QSvgNode *node,
     }
 }
 
+static void parseExtendedAttributes(QSvgNode *node,
+                                    const QSvgAttributes &attributes,
+                                    QSvgHandler *handler)
+{
+    if (handler->options().testFlag(QtSvg::Tiny12FeaturesOnly))
+        return;
+
+    if (!attributes.mask.isEmpty()) {
+        QString maskStr = attributes.mask.toString().trimmed();
+        if (maskStr.size() > 3 && maskStr.mid(0, 3) == QLatin1String("url"))
+            maskStr = maskStr.mid(3, maskStr.size() - 3);
+        QString maskId = idFromUrl(maskStr);
+        if (maskId.startsWith(QLatin1Char('#'))) //TODO: handle urls and ids in a single place
+            maskId.remove(0, 1);
+
+        node->setMaskId(maskId);
+    }
+
+    if (!attributes.markerStart.isEmpty() &&
+        !handler->options().testFlag(QtSvg::Tiny12FeaturesOnly)) {
+        QString markerStr = attributes.markerStart.toString().trimmed();
+        if (markerStr.size() > 3 && markerStr.mid(0, 3) == QLatin1String("url"))
+            markerStr = markerStr.mid(3, markerStr.size() - 3);
+        QString markerId = idFromUrl(markerStr);
+        if (markerId.startsWith(QLatin1Char('#'))) //TODO: handle urls and ids in a single place
+            markerId.remove(0, 1);
+        node->setMarkerStartId(markerId);
+    }
+    if (!attributes.markerMid.isEmpty() &&
+        !handler->options().testFlag(QtSvg::Tiny12FeaturesOnly)) {
+        QString markerStr = attributes.markerMid.toString().trimmed();
+        if (markerStr.size() > 3 && markerStr.mid(0, 3) == QLatin1String("url"))
+            markerStr = markerStr.mid(3, markerStr.size() - 3);
+        QString markerId = idFromUrl(markerStr);
+        if (markerId.startsWith(QLatin1Char('#'))) //TODO: handle urls and ids in a single place
+            markerId.remove(0, 1);
+        node->setMarkerMidId(markerId);
+    }
+    if (!attributes.markerEnd.isEmpty() &&
+        !handler->options().testFlag(QtSvg::Tiny12FeaturesOnly)) {
+        QString markerStr = attributes.markerEnd.toString().trimmed();
+        if (markerStr.size() > 3 && markerStr.mid(0, 3) == QLatin1String("url"))
+            markerStr = markerStr.mid(3, markerStr.size() - 3);
+        QString markerId = idFromUrl(markerStr);
+        if (markerId.startsWith(QLatin1Char('#'))) //TODO: handle urls and ids in a single place
+            markerId.remove(0, 1);
+        node->setMarkerEndId(markerId);
+    }
+
+    if (!attributes.filter.isEmpty() &&
+        !handler->options().testFlag(QtSvg::Tiny12FeaturesOnly)) {
+        QString filterStr = attributes.filter.toString().trimmed();
+
+        if (filterStr.size() > 3 && filterStr.mid(0, 3) == QLatin1String("url"))
+            filterStr = filterStr.mid(3, filterStr.size() - 3);
+        QString filterId = idFromUrl(filterStr);
+        if (filterId.startsWith(QLatin1Char('#'))) //TODO: handle urls and ids in a single place
+            filterId.remove(0, 1);
+        node->setFilterId(filterId);
+    }
+
+}
+
 static void parseRenderingHints(QSvgNode *node,
                                 const QSvgAttributes &attributes,
                                 QSvgHandler *)
@@ -2271,6 +2390,7 @@ static bool parseStyle(QSvgNode *node,
     parseCompOp(node, attributes, handler);
     parseRenderingHints(node, attributes, handler);
     parseOthers(node, attributes, handler);
+    parseExtendedAttributes(node, attributes, handler);
 
 #if 0
     value = attributes.value("audio-level");
@@ -2555,14 +2675,6 @@ static QSvgNode *createDefsNode(QSvgNode *parent,
     return defs;
 }
 
-static bool parseDescNode(QSvgNode *parent,
-                          const QXmlStreamAttributes &attributes,
-                          QSvgHandler *)
-{
-    Q_UNUSED(parent); Q_UNUSED(attributes);
-    return true;
-}
-
 static bool parseDiscardNode(QSvgNode *parent,
                              const QXmlStreamAttributes &attributes,
                              QSvgHandler *)
@@ -2598,7 +2710,7 @@ static QSvgStyleProperty *createFontNode(QSvgNode *parent,
 
     qreal horizAdvX = toDouble(hax);
 
-    while (parent && parent->type() != QSvgNode::DOC) {
+    while (parent && parent->type() != QSvgNode::Doc) {
         parent = parent->parent();
     }
 
@@ -2740,10 +2852,10 @@ static QSvgNode *createImageNode(QSvgNode *parent,
     qreal nx = toDouble(x);
     qreal ny = toDouble(y);
     QSvgHandler::LengthType type;
-    qreal nwidth = parseLength(width.toString(), type, handler);
+    qreal nwidth = parseLength(width.toString(), &type, handler);
     nwidth = convertToPixels(nwidth, true, type);
 
-    qreal nheight = parseLength(height.toString(), type, handler);
+    qreal nheight = parseLength(height.toString(), &type, handler);
     nheight = convertToPixels(nheight, false, type);
 
     filename = filename.trimmed();
@@ -2776,7 +2888,9 @@ static QSvgNode *createImageNode(QSvgNode *parent,
                 filename = info.absoluteDir().absoluteFilePath(filename);
             }
         }
-        image = QImage(filename);
+
+        if (handler->trustedSourceMode() || !QImageReader::imageFormat(filename).startsWith("svg"))
+            image = QImage(filename);
     }
 
     if (image.isNull()) {
@@ -2900,7 +3014,7 @@ static QSvgStyleProperty *createLinearGradientNode(QSvgNode *node,
         ny2 =  convertToNumber(y2, handler);
 
     QSvgNode *itr = node;
-    while (itr && itr->type() != QSvgNode::DOC) {
+    while (itr && itr->type() != QSvgNode::Doc) {
         itr = itr->parent();
     }
 
@@ -2942,15 +3056,635 @@ static bool parseMpathNode(QSvgNode *parent,
     return true;
 }
 
+static bool parseMaskNode(QSvgNode *parent,
+                          const QXmlStreamAttributes &attributes,
+                          QSvgHandler *)
+{
+    Q_UNUSED(parent); Q_UNUSED(attributes);
+    return true;
+}
+
+static bool parseMarkerNode(QSvgNode *,
+                          const QXmlStreamAttributes &,
+                          QSvgHandler *)
+{
+    return true;
+}
+
+static QSvgNode *createMaskNode(QSvgNode *parent,
+                          const QXmlStreamAttributes &attributes,
+                          QSvgHandler *handler)
+{
+    const QStringView x      = attributes.value(QLatin1String("x"));
+    const QStringView y      = attributes.value(QLatin1String("y"));
+    const QStringView width  = attributes.value(QLatin1String("width"));
+    const QStringView height = attributes.value(QLatin1String("height"));
+    const QStringView mU     = attributes.value(QLatin1String("maskUnits"));
+    const QStringView mCU    = attributes.value(QLatin1String("maskContentUnits"));
+
+    QtSvg::UnitTypes nmU = mU.contains(QLatin1String("userSpaceOnUse")) ?
+                QtSvg::UnitTypes::userSpaceOnUse : QtSvg::UnitTypes::objectBoundingBox;
+
+    QtSvg::UnitTypes nmCU = mCU.contains(QLatin1String("objectBoundingBox")) ?
+                QtSvg::UnitTypes::objectBoundingBox : QtSvg::UnitTypes::userSpaceOnUse;
+
+    bool ok;
+    QSvgHandler::LengthType type;
+
+    QtSvg::UnitTypes nmUx = nmU;
+    QtSvg::UnitTypes nmUy = nmU;
+    QtSvg::UnitTypes nmUw = nmU;
+    QtSvg::UnitTypes nmUh = nmU;
+    qreal nx = parseLength(x.toString(), &type, handler, &ok);
+    nx = convertToPixels(nx, true, type);
+    if (x.isEmpty() || !ok) {
+        nx = -0.1;
+        nmUx = QtSvg::UnitTypes::objectBoundingBox;
+    } else if (type == QSvgHandler::LT_PERCENT && nmU == QtSvg::UnitTypes::userSpaceOnUse) {
+        nx = nx / 100. * parent->document()->viewBox().width();
+    } else if (type == QSvgHandler::LT_PERCENT) {
+        nx = nx / 100.;
+    }
+
+    qreal ny = parseLength(y.toString(), &type, handler, &ok);
+    ny = convertToPixels(ny, true, type);
+    if (y.isEmpty() || !ok) {
+        ny = -0.1;
+        nmUy = QtSvg::UnitTypes::objectBoundingBox;
+    } else if (type == QSvgHandler::LT_PERCENT && nmU == QtSvg::UnitTypes::userSpaceOnUse) {
+        ny = ny / 100. * parent->document()->viewBox().height();
+    } else if (type == QSvgHandler::LT_PERCENT) {
+        ny = ny / 100.;
+    }
+
+    qreal nwidth = parseLength(width.toString(), &type, handler, &ok);
+    nwidth = convertToPixels(nwidth, true, type);
+    if (width.isEmpty() || !ok) {
+        nwidth = 1.2;
+        nmUw = QtSvg::UnitTypes::objectBoundingBox;
+    } else if (type == QSvgHandler::LT_PERCENT && nmU == QtSvg::UnitTypes::userSpaceOnUse) {
+        nwidth = nwidth / 100. * parent->document()->viewBox().width();
+    } else if (type == QSvgHandler::LT_PERCENT) {
+        nwidth = nwidth / 100.;
+    }
+
+    qreal nheight = parseLength(height.toString(), &type, handler, &ok);
+    nheight = convertToPixels(nheight, true, type);
+    if (height.isEmpty() || !ok) {
+        nheight = 1.2;
+        nmUh = QtSvg::UnitTypes::objectBoundingBox;
+    } else if (type == QSvgHandler::LT_PERCENT && nmU == QtSvg::UnitTypes::userSpaceOnUse) {
+        nheight = nheight / 100. * parent->document()->viewBox().height();
+    } else if (type == QSvgHandler::LT_PERCENT) {
+        nheight = nheight / 100.;
+    }
+
+    QRectF bounds(nx, ny, nwidth, nheight);
+    if (bounds.isEmpty())
+        return nullptr;
+
+    QSvgNode *mask = new QSvgMask(parent, QSvgRectF(bounds, nmUx, nmUy, nmUw, nmUh), nmCU);
+
+    return mask;
+}
+
+static void parseFilterBounds(QSvgNode *, const QXmlStreamAttributes &attributes,
+                              QSvgHandler *handler, QSvgRectF *rect)
+{
+    const QStringView xStr        = attributes.value(QLatin1String("x"));
+    const QStringView yStr        = attributes.value(QLatin1String("y"));
+    const QStringView widthStr    = attributes.value(QLatin1String("width"));
+    const QStringView heightStr   = attributes.value(QLatin1String("height"));
+
+    qreal x = 0;
+    if (!xStr.isEmpty()) {
+        QSvgHandler::LengthType type;
+        x = parseLength(xStr.toString(), &type, handler);
+        if (type != QSvgHandler::LT_PT)
+            x = convertToPixels(x, true, type);
+        if (type == QSvgHandler::LT_PERCENT) {
+            x /= 100.;
+            rect->setUnitX(QtSvg::UnitTypes::objectBoundingBox);
+        }
+        rect->setX(x);
+    } else {
+        rect->setX(-0.1);
+        rect->setUnitX(QtSvg::UnitTypes::objectBoundingBox);
+    }
+    qreal y = 0;
+    if (!yStr.isEmpty()) {
+        QSvgHandler::LengthType type;
+        y = parseLength(yStr.toString(), &type, handler);
+        if (type != QSvgHandler::LT_PT)
+            y = convertToPixels(y, false, type);
+        if (type == QSvgHandler::LT_PERCENT) {
+            y /= 100.;
+            rect->setUnitX(QtSvg::UnitTypes::objectBoundingBox);
+        }
+        rect->setY(y);
+    } else {
+        rect->setY(-0.1);
+        rect->setUnitY(QtSvg::UnitTypes::objectBoundingBox);
+    }
+    qreal width = 0;
+    if (!widthStr.isEmpty()) {
+        QSvgHandler::LengthType type;
+        width = parseLength(widthStr.toString(), &type, handler);
+        if (type != QSvgHandler::LT_PT)
+            width = convertToPixels(width, true, type);
+        if (type == QSvgHandler::LT_PERCENT) {
+            width /= 100.;
+            rect->setUnitX(QtSvg::UnitTypes::objectBoundingBox);
+        }
+        rect->setWidth(width);
+    } else {
+        rect->setWidth(1.2);
+        rect->setUnitW(QtSvg::UnitTypes::objectBoundingBox);
+    }
+    qreal height = 0;
+    if (!heightStr.isEmpty()) {
+        QSvgHandler::LengthType type;
+        height = parseLength(heightStr.toString(), &type, handler);
+        if (type != QSvgHandler::LT_PT)
+            height = convertToPixels(height, false, type);
+        if (type == QSvgHandler::LT_PERCENT) {
+            height /= 100.;
+            rect->setUnitX(QtSvg::UnitTypes::objectBoundingBox);
+        }
+        rect->setHeight(height);
+    } else {
+        rect->setHeight(1.2);
+        rect->setUnitH(QtSvg::UnitTypes::objectBoundingBox);
+    }
+}
+
+static QSvgNode *createFilterNode(QSvgNode *parent,
+                          const QXmlStreamAttributes &attributes,
+                          QSvgHandler *handler)
+{
+    QString fU = attributes.value(QLatin1String("filterUnits")).toString();
+    QString pU = attributes.value(QLatin1String("primitiveUnits")).toString();
+
+    QtSvg::UnitTypes filterUnits = fU.contains(QLatin1String("userSpaceOnUse")) ?
+                QtSvg::UnitTypes::userSpaceOnUse : QtSvg::UnitTypes::objectBoundingBox;
+
+    QtSvg::UnitTypes primitiveUnits = pU.contains(QLatin1String("objectBoundingBox")) ?
+                QtSvg::UnitTypes::objectBoundingBox : QtSvg::UnitTypes::userSpaceOnUse;
+
+    QSvgRectF rect;
+    parseFilterBounds(parent, attributes, handler, &rect);
+
+    QSvgNode *filter = new QSvgFilterContainer(parent, rect, filterUnits, primitiveUnits);
+    return filter;
+}
+
+static void parseFilterAttributes(QSvgNode *parent, const QXmlStreamAttributes &attributes,
+                                  QSvgHandler *handler, QString *inString, QString *outString,
+                                  QSvgRectF *rect)
+{
+    *inString = attributes.value(QLatin1String("in")).toString();
+    *outString = attributes.value(QLatin1String("result")).toString();
+
+    parseFilterBounds(parent, attributes, handler, rect);
+}
+
+static QSvgNode *createFeColorMatrixNode(QSvgNode *parent,
+                                        const QXmlStreamAttributes &attributes,
+                                        QSvgHandler *handler)
+{
+    const QString typeString = attributes.value(QLatin1String("type")).toString();
+    QString valuesString = attributes.value(QLatin1String("values")).toString();
+
+    QString inputString;
+    QString outputString;
+    QSvgRectF rect;
+
+    QSvgFeColorMatrix::ColorShiftType type;
+    QSvgFeColorMatrix::Matrix values;
+    values.fill(0);
+
+    parseFilterAttributes(parent, attributes, handler,
+                          &inputString, &outputString, &rect);
+
+    if (typeString.startsWith(QLatin1String("saturate")))
+        type = QSvgFeColorMatrix::ColorShiftType::Saturate;
+    else if (typeString.startsWith(QLatin1String("hueRotate")))
+        type = QSvgFeColorMatrix::ColorShiftType::HueRotate;
+    else if (typeString.startsWith(QLatin1String("luminanceToAlpha")))
+        type = QSvgFeColorMatrix::ColorShiftType::LuminanceToAlpha;
+    else
+        type = QSvgFeColorMatrix::ColorShiftType::Matrix;
+
+    if (!valuesString.isEmpty()) {
+        static QRegularExpression delimiterRE(QLatin1String("[,\\s]"));
+        const QStringList valueStringList = valuesString.split(delimiterRE, Qt::SkipEmptyParts);
+
+        for (int i = 0, j = 0; i < qMin(20, valueStringList.size()); i++) {
+            bool ok;
+            qreal v = toDouble(valueStringList.at(i), &ok);
+            if (ok) {
+                values.data()[j] = v;
+                j++;
+            }
+        }
+    } else {
+        values.setToIdentity();
+    }
+
+    QSvgNode *filter = new QSvgFeColorMatrix(parent, inputString, outputString, rect,
+                                             type, values);
+    return filter;
+}
+
+static QSvgNode *createFeGaussianBlurNode(QSvgNode *parent,
+                                          const QXmlStreamAttributes &attributes,
+                                          QSvgHandler *handler)
+{
+    const QString edgeModeString    = attributes.value(QLatin1String("edgeMode")).toString();
+    QString stdDeviationString  = attributes.value(QLatin1String("stdDeviation")).toString();
+
+    QString inputString;
+    QString outputString;
+    QSvgRectF rect;
+
+    QSvgFeGaussianBlur::EdgeMode edgemode = QSvgFeGaussianBlur::EdgeMode::Duplicate;
+
+    parseFilterAttributes(parent, attributes, handler,
+                          &inputString, &outputString, &rect);
+    qreal stdDeviationX = 0;
+    qreal stdDeviationY = 0;
+    if (stdDeviationString.contains(QStringLiteral(" "))){
+        stdDeviationX = qMax(0., toDouble(stdDeviationString.split(QStringLiteral(" ")).first()));
+        stdDeviationY = qMax(0., toDouble(stdDeviationString.split(QStringLiteral(" ")).last()));
+    } else {
+        stdDeviationY = stdDeviationX = qMax(0., toDouble(stdDeviationString));
+    }
+
+    if (edgeModeString.startsWith(QLatin1String("wrap")))
+        edgemode = QSvgFeGaussianBlur::EdgeMode::Wrap;
+    else if (edgeModeString.startsWith(QLatin1String("none")))
+        edgemode = QSvgFeGaussianBlur::EdgeMode::None;
+
+    QSvgNode *filter = new QSvgFeGaussianBlur(parent, inputString, outputString, rect,
+                                              stdDeviationX, stdDeviationY, edgemode);
+    return filter;
+}
+
+static QSvgNode *createFeOffsetNode(QSvgNode *parent,
+                                    const QXmlStreamAttributes &attributes,
+                                    QSvgHandler *handler)
+{
+    QStringView dxString = attributes.value(QLatin1String("dx"));
+    QStringView dyString = attributes.value(QLatin1String("dy"));
+
+    QString inputString;
+    QString outputString;
+    QSvgRectF rect;
+
+    parseFilterAttributes(parent, attributes, handler,
+                          &inputString, &outputString, &rect);
+
+    qreal dx = 0;
+    if (!dxString.isEmpty()) {
+        QSvgHandler::LengthType type;
+        dx = parseLength(dxString.toString(), &type, handler);
+        if (type != QSvgHandler::LT_PT)
+            dx = convertToPixels(dx, true, type);
+    }
+
+    qreal dy = 0;
+    if (!dyString.isEmpty()) {
+        QSvgHandler::LengthType type;
+        dy = parseLength(dyString.toString(), &type, handler);
+        if (type != QSvgHandler::LT_PT)
+            dy = convertToPixels(dy, true, type);
+    }
+
+    QSvgNode *filter = new QSvgFeOffset(parent, inputString, outputString, rect,
+                                        dx, dy);
+    return filter;
+}
+
+static QSvgNode *createFeCompositeNode(QSvgNode *parent,
+                                  const QXmlStreamAttributes &attributes,
+                                  QSvgHandler *handler)
+{
+    QString in2String        = attributes.value(QLatin1String("in2")).toString();
+    QString operatorString   = attributes.value(QLatin1String("operator")).toString();
+    QString k1String         = attributes.value(QLatin1String("k1")).toString();
+    QString k2String         = attributes.value(QLatin1String("k2")).toString();
+    QString k3String         = attributes.value(QLatin1String("k3")).toString();
+    QString k4String         = attributes.value(QLatin1String("k4")).toString();
+
+    QString inputString;
+    QString outputString;
+    QSvgRectF rect;
+
+    parseFilterAttributes(parent, attributes, handler,
+                          &inputString, &outputString, &rect);
+
+    QSvgFeComposite::Operator op = QSvgFeComposite::Operator::Over;
+    if (operatorString.startsWith(QStringLiteral("in")))
+        op = QSvgFeComposite::Operator::In;
+    else if (operatorString.startsWith(QStringLiteral("out")))
+        op = QSvgFeComposite::Operator::Out;
+    else if (operatorString.startsWith(QStringLiteral("atop")))
+        op = QSvgFeComposite::Operator::Atop;
+    else if (operatorString.startsWith(QStringLiteral("xor")))
+        op = QSvgFeComposite::Operator::Xor;
+    else if (operatorString.startsWith(QStringLiteral("lighter")))
+        op = QSvgFeComposite::Operator::Lighter;
+    else if (operatorString.startsWith(QStringLiteral("arithmetic")))
+        op = QSvgFeComposite::Operator::Arithmetic;
+
+    QVector4D k(0, 0, 0, 0);
+
+    if (op == QSvgFeComposite::Operator::Arithmetic) {
+        bool ok;
+        qreal v = toDouble(k1String, &ok);
+        if (ok)
+            k.setX(v);
+        v = toDouble(k2String, &ok);
+        if (ok)
+            k.setY(v);
+        v = toDouble(k3String, &ok);
+        if (ok)
+            k.setZ(v);
+        v = toDouble(k4String, &ok);
+        if (ok)
+            k.setW(v);
+    }
+
+    QSvgNode *filter = new QSvgFeComposite(parent, inputString, outputString, rect,
+                                           in2String, op, k);
+    return filter;
+}
+
+
+static QSvgNode *createFeMergeNode(QSvgNode *parent,
+                                   const QXmlStreamAttributes &attributes,
+                                   QSvgHandler *handler)
+{
+    QString inputString;
+    QString outputString;
+    QSvgRectF rect;
+
+    parseFilterAttributes(parent, attributes, handler,
+                          &inputString, &outputString, &rect);
+
+    QSvgNode *filter = new QSvgFeMerge(parent, inputString, outputString, rect);
+    return filter;
+}
+
+static QSvgNode *createFeFloodNode(QSvgNode *parent,
+                                   const QXmlStreamAttributes &attributes,
+                                   QSvgHandler *handler)
+{
+    QStringView colorStr          = attributes.value(QLatin1String("flood-color"));
+    const QStringView opacityStr  = attributes.value(QLatin1String("flood-opacity"));
+
+    QColor color;
+    if (!constructColor(colorStr, opacityStr, color, handler))
+        color = QColor(Qt::black);
+
+    QString inputString;
+    QString outputString;
+    QSvgRectF rect;
+
+    parseFilterAttributes(parent, attributes, handler,
+                          &inputString, &outputString, &rect);
+
+    QSvgNode *filter = new QSvgFeFlood(parent, inputString, outputString, rect, color);
+    return filter;
+}
+
+static QSvgNode *createFeMergeNodeNode(QSvgNode *parent,
+                                       const QXmlStreamAttributes &attributes,
+                                       QSvgHandler *handler)
+{
+    QString inputString;
+    QString outputString;
+    QSvgRectF rect;
+
+    parseFilterAttributes(parent, attributes, handler,
+                          &inputString, &outputString, &rect);
+
+    QSvgNode *filter = new QSvgFeMergeNode(parent, inputString, outputString, rect);
+    return filter;
+}
+
+static bool parseSymbolLikeAttributes(const QXmlStreamAttributes &attributes, QSvgHandler *handler,
+                                      QRectF *rect, QRectF *viewBox, QPointF *refPoint,
+                                      QSvgSymbolLike::PreserveAspectRatios *aspect,
+                                      QSvgSymbolLike::Overflow *overflow,
+                                      bool marker = false)
+{
+    const QStringView xStr        = attributes.value(QLatin1String("x"));
+    const QStringView yStr        = attributes.value(QLatin1String("y"));
+    const QStringView refXStr     = attributes.value(QLatin1String("refX"));
+    const QStringView refYStr     = attributes.value(QLatin1String("refY"));
+    const QStringView widthStr    = attributes.value(QLatin1String(marker ? "markerWidth":"width"));
+    const QStringView heightStr   = attributes.value(QLatin1String(marker ? "markerHeight":"height"));
+    const QString pAspectRStr     = attributes.value(QLatin1String("preserveAspectRatio")).toString();
+    const QStringView overflowStr = attributes.value(QLatin1String("overflow"));
+
+    QString viewBoxStr = attributes.value(QLatin1String("viewBox")).toString();
+
+
+    qreal x = 0;
+    if (!xStr.isEmpty()) {
+        QSvgHandler::LengthType type;
+        x = parseLength(xStr.toString(), &type, handler);
+        if (type != QSvgHandler::LT_PT)
+            x = convertToPixels(x, true, type);
+    }
+    qreal y = 0;
+    if (!yStr.isEmpty()) {
+        QSvgHandler::LengthType type;
+        y = parseLength(yStr.toString(), &type, handler);
+        if (type != QSvgHandler::LT_PT)
+            y = convertToPixels(y, false, type);
+    }
+    qreal width = 0;
+    if (!widthStr.isEmpty()) {
+        QSvgHandler::LengthType type;
+        width = parseLength(widthStr.toString(), &type, handler);
+        if (type != QSvgHandler::LT_PT)
+            width = convertToPixels(width, true, type);
+    }
+    qreal height = 0;
+    if (!heightStr.isEmpty()) {
+        QSvgHandler::LengthType type;
+        height = parseLength(heightStr.toString(), &type, handler);
+        if (type != QSvgHandler::LT_PT)
+            height = convertToPixels(height, false, type);
+    }
+
+    *rect = QRectF(x, y, width, height);
+
+    x = 0;
+    if (!refXStr.isEmpty()) {
+        QSvgHandler::LengthType type;
+        x = parseLength(refXStr.toString(), &type, handler);
+        if (type != QSvgHandler::LT_PT)
+            x = convertToPixels(x, true, type);
+    }
+    y = 0;
+    if (!refYStr.isEmpty()) {
+        QSvgHandler::LengthType type;
+        y = parseLength(refYStr.toString(), &type, handler);
+        if (type != QSvgHandler::LT_PT)
+            y = convertToPixels(y, false, type);
+    }
+    *refPoint = QPointF(x,y);
+
+    QStringList viewBoxValues;
+    if (!viewBoxStr.isEmpty()) {
+        viewBoxStr = viewBoxStr.replace(QLatin1Char(' '), QLatin1Char(','));
+        viewBoxStr = viewBoxStr.replace(QLatin1Char('\r'), QLatin1Char(','));
+        viewBoxStr = viewBoxStr.replace(QLatin1Char('\n'), QLatin1Char(','));
+        viewBoxStr = viewBoxStr.replace(QLatin1Char('\t'), QLatin1Char(','));
+        viewBoxValues = viewBoxStr.split(QLatin1Char(','), Qt::SkipEmptyParts);
+    }
+    if (viewBoxValues.size() == 4) {
+        QString xStr      = viewBoxValues.at(0).trimmed();
+        QString yStr      = viewBoxValues.at(1).trimmed();
+        QString widthStr  = viewBoxValues.at(2).trimmed();
+        QString heightStr = viewBoxValues.at(3).trimmed();
+
+        QSvgHandler::LengthType lt;
+        qreal x = parseLength(xStr, &lt, handler);
+        qreal y = parseLength(yStr, &lt, handler);
+        qreal w = parseLength(widthStr, &lt, handler);
+        qreal h = parseLength(heightStr, &lt, handler);
+
+        *viewBox = QRectF(x, y, w, h);
+
+    } else if (width > 0 && height > 0) {
+        *viewBox = QRectF(0, 0, width, height);
+    } else {
+        *viewBox = handler->document()->viewBox();
+    }
+
+    if (viewBox->isNull())
+        return false;
+
+    QStringList pAspectRStrs = pAspectRStr.split(QLatin1String(" "));
+    QSvgSymbolLike::PreserveAspectRatio aspectX = QSvgSymbolLike::PreserveAspectRatio::xMid;
+    QSvgSymbolLike::PreserveAspectRatio aspectY = QSvgSymbolLike::PreserveAspectRatio::yMid;
+    QSvgSymbolLike::PreserveAspectRatio aspectMS = QSvgSymbolLike::PreserveAspectRatio::meet;
+
+    for (auto &pAStr : std::as_const(pAspectRStrs)) {
+        if (pAStr.startsWith(QLatin1String("none"))) {
+            aspectX = QSvgSymbolLike::PreserveAspectRatio::None;
+            aspectY = QSvgSymbolLike::PreserveAspectRatio::None;
+        }else {
+            if (pAStr.startsWith(QLatin1String("xMin")))
+                aspectX = QSvgSymbolLike::PreserveAspectRatio::xMin;
+            else if (pAStr.startsWith(QLatin1String("xMax")))
+                aspectX = QSvgSymbolLike::PreserveAspectRatio::xMax;
+            if (pAStr.endsWith(QLatin1String("YMin")))
+                aspectY = QSvgSymbolLike::PreserveAspectRatio::yMin;
+            else if (pAStr.endsWith(QLatin1String("YMax")))
+                aspectY = QSvgSymbolLike::PreserveAspectRatio::yMax;
+        }
+
+        if (pAStr.endsWith(QLatin1String("slice")))
+            aspectMS = QSvgSymbolLike::PreserveAspectRatio::slice;
+    }
+    *aspect = aspectX | aspectY | aspectMS;
+
+    // overflow is not limited to the symbol element but it is often found with the symbol element.
+    // the symbol element makes little sense without the overflow attribute so it is added here.
+    // if we decide to remove this from QSvgSymbol, the default value should be set to visible.
+
+    // The default value is visible but chrome uses default value hidden.
+    *overflow = QSvgSymbolLike::Overflow::Hidden;
+
+    if (overflowStr.endsWith(QLatin1String("auto")))
+        *overflow = QSvgSymbolLike::Overflow::Auto;
+    else if (overflowStr.endsWith(QLatin1String("visible")))
+        *overflow = QSvgSymbolLike::Overflow::Visible;
+    else if (overflowStr.endsWith(QLatin1String("hidden")))
+        *overflow = QSvgSymbolLike::Overflow::Hidden;
+    else if (overflowStr.endsWith(QLatin1String("scroll")))
+        *overflow = QSvgSymbolLike::Overflow::Scroll;
+
+    return true;
+}
+
+static QSvgNode *createSymbolNode(QSvgNode *parent,
+                          const QXmlStreamAttributes &attributes,
+                          QSvgHandler *handler)
+{
+    QRectF rect, viewBox;
+    QPointF refP;
+    QSvgSymbolLike::PreserveAspectRatios aspect;
+    QSvgSymbolLike::Overflow overflow;
+
+    if (!parseSymbolLikeAttributes(attributes, handler, &rect, &viewBox, &refP, &aspect, &overflow))
+        return nullptr;
+
+    refP = QPointF(0, 0); //refX, refY is ignored in Symbol in Firefox and Chrome.
+    QSvgNode *symbol = new QSvgSymbol(parent, rect, viewBox, refP, aspect, overflow);
+    return symbol;
+}
+
+static QSvgNode *createMarkerNode(QSvgNode *parent,
+                                  const QXmlStreamAttributes &attributes,
+                                  QSvgHandler *handler)
+{
+    QRectF rect, viewBox;
+    QPointF refP;
+    QSvgSymbolLike::PreserveAspectRatios aspect;
+    QSvgSymbolLike::Overflow overflow;
+
+    const QString orientStr      = attributes.value(QLatin1String("orient")).toString();
+    const QString markerUnitsStr = attributes.value(QLatin1String("markerUnits")).toString();
+
+    qreal orientationAngle = 0;
+    QSvgMarker::Orientation orientation;
+    if (orientStr.startsWith(QLatin1String("auto-start-reverse")))
+        orientation = QSvgMarker::Orientation::AutoStartReverse;
+    else if (orientStr.startsWith(QLatin1String("auto")))
+        orientation = QSvgMarker::Orientation::Auto;
+    else {
+        orientation = QSvgMarker::Orientation::Value;
+        bool ok;
+        qreal a;
+        if (orientStr.endsWith(QStringLiteral("turn")))
+            a = 360. * toDouble(orientStr.mid(0, orientStr.length()-4), &ok);
+        else if (orientStr.endsWith(QStringLiteral("grad")))
+            a = toDouble(orientStr.mid(0, orientStr.length()-4), &ok);
+        else if (orientStr.endsWith(QStringLiteral("rad")))
+            a = 180. / M_PI * toDouble(orientStr.mid(0, orientStr.length()-3), &ok);
+        else
+            a = toDouble(orientStr, &ok);
+        if (ok)
+            orientationAngle = a;
+    }
+
+    QSvgMarker::MarkerUnits markerUnits = QSvgMarker::MarkerUnits::StrokeWidth;
+    if (markerUnitsStr.startsWith(QLatin1String("userSpaceOnUse")))
+        markerUnits = QSvgMarker::MarkerUnits::UserSpaceOnUse;
+
+    if (!parseSymbolLikeAttributes(attributes, handler, &rect, &viewBox, &refP, &aspect, &overflow, true))
+        return nullptr;
+
+    QSvgNode *marker = new QSvgMarker(parent, rect, viewBox, refP, aspect, overflow,
+                                      orientation, orientationAngle, markerUnits);
+    return marker;
+}
+
 static QSvgNode *createPathNode(QSvgNode *parent,
                                 const QXmlStreamAttributes &attributes,
-                                QSvgHandler *)
+                                QSvgHandler *handler)
 {
     QStringView data = attributes.value(QLatin1String("d"));
 
     QPainterPath qpath;
     qpath.setFillRule(Qt::WindingFill);
-    if (!parsePathDataFast(data, qpath))
+    if (!parsePathDataFast(data, qpath, !handler->trustedSourceMode()))
         qCWarning(lcSvgHandler, "Invalid path data; path truncated.");
 
     QSvgNode *path = new QSvgPath(parent, qpath);
@@ -3015,7 +3749,7 @@ static QSvgStyleProperty *createRadialGradientNode(QSvgNode *node,
     if (!cy.isEmpty())
         ncy = toDouble(cy);
 
-    qreal nr = 0.0;
+    qreal nr = 0.5;
     if (!r.isEmpty())
         nr = toDouble(r);
     if (nr <= 0.0)
@@ -3050,11 +3784,11 @@ static QSvgNode *createRectNode(QSvgNode *parent,
 
     bool ok = true;
     QSvgHandler::LengthType type;
-    qreal nwidth = parseLength(width.toString(), type, handler, &ok);
+    qreal nwidth = parseLength(width.toString(), &type, handler, &ok);
     if (!ok)
         return nullptr;
     nwidth = convertToPixels(nwidth, true, type);
-    qreal nheight = parseLength(height.toString(), type, handler, &ok);
+    qreal nheight = parseLength(height.toString(), &type, handler, &ok);
     if (!ok)
         return nullptr;
     nheight = convertToPixels(nheight, true, type);
@@ -3084,9 +3818,7 @@ static QSvgNode *createRectNode(QSvgNode *parent,
     nrx *= (100/(bounds.width()/2));
     nry *= (100/(bounds.height()/2));
 
-    QSvgNode *rect = new QSvgRect(parent, bounds,
-                                  int(nrx),
-                                  int(nry));
+    QSvgNode *rect = new QSvgRect(parent, bounds, nrx, nry);
     return rect;
 }
 
@@ -3214,7 +3946,7 @@ static QSvgNode *createSvgNode(QSvgNode *parent,
 {
     Q_UNUSED(parent); Q_UNUSED(attributes);
 
-    QSvgTinyDocument *node = new QSvgTinyDocument();
+    QSvgTinyDocument *node = new QSvgTinyDocument(handler->options());
     const QStringView widthStr  = attributes.value(QLatin1String("width"));
     const QStringView heightStr = attributes.value(QLatin1String("height"));
     QString viewBoxStr = attributes.value(QLatin1String("viewBox")).toString();
@@ -3222,14 +3954,14 @@ static QSvgNode *createSvgNode(QSvgNode *parent,
     QSvgHandler::LengthType type = QSvgHandler::LT_PX; // FIXME: is the default correct?
     qreal width = 0;
     if (!widthStr.isEmpty()) {
-        width = parseLength(widthStr.toString(), type, handler);
+        width = parseLength(widthStr.toString(), &type, handler);
         if (type != QSvgHandler::LT_PT)
             width = convertToPixels(width, true, type);
         node->setWidth(int(width), type == QSvgHandler::LT_PERCENT);
     }
     qreal height = 0;
     if (!heightStr.isEmpty()) {
-        height = parseLength(heightStr.toString(), type, handler);
+        height = parseLength(heightStr.toString(), &type, handler);
         if (type != QSvgHandler::LT_PT)
             height = convertToPixels(height, false, type);
         node->setHeight(int(height), type == QSvgHandler::LT_PERCENT);
@@ -3250,10 +3982,10 @@ static QSvgNode *createSvgNode(QSvgNode *parent,
         QString heightStr = viewBoxValues.at(3).trimmed();
 
         QSvgHandler::LengthType lt;
-        qreal x = parseLength(xStr, lt, handler);
-        qreal y = parseLength(yStr, lt, handler);
-        qreal w = parseLength(widthStr, lt, handler);
-        qreal h = parseLength(heightStr, lt, handler);
+        qreal x = parseLength(xStr, &lt, handler);
+        qreal y = parseLength(yStr, &lt, handler);
+        qreal w = parseLength(widthStr, &lt, handler);
+        qreal h = parseLength(heightStr, &lt, handler);
 
         node->setViewBox(QRectF(x, y, w, h));
 
@@ -3278,11 +4010,113 @@ static QSvgNode *createSwitchNode(QSvgNode *parent,
     return node;
 }
 
+static QSvgNode *createPatternNode(QSvgNode *parent,
+                                   const QXmlStreamAttributes &attributes,
+                                   QSvgHandler *handler)
+{
+    const QStringView x      = attributes.value(QLatin1String("x"));
+    const QStringView y      = attributes.value(QLatin1String("y"));
+    const QStringView width  = attributes.value(QLatin1String("width"));
+    const QStringView height = attributes.value(QLatin1String("height"));
+    const QStringView patternUnits     = attributes.value(QLatin1String("patternUnits"));
+    const QStringView patternContentUnits    = attributes.value(QLatin1String("patternContentUnits"));
+    const QStringView patternTransform = attributes.value(QLatin1String("patternTransform"));
+
+    QtSvg::UnitTypes nPatternUnits = patternUnits.contains(QLatin1String("userSpaceOnUse")) ?
+                                        QtSvg::UnitTypes::userSpaceOnUse : QtSvg::UnitTypes::objectBoundingBox;
+
+    QtSvg::UnitTypes nPatternContentUnits = patternContentUnits.contains(QLatin1String("objectBoundingBox")) ?
+                                               QtSvg::UnitTypes::objectBoundingBox : QtSvg::UnitTypes::userSpaceOnUse;
+
+    QString viewBoxStr = attributes.value(QLatin1String("viewBox")).toString();
+
+    bool ok = false;
+    QSvgHandler::LengthType type;
+
+    qreal nx = parseLength(x.toString(), &type, handler, &ok);
+    nx = convertToPixels(nx, true, type);
+    if (!ok)
+        nx = 0.0;
+    else if (type == QSvgHandler::LT_PERCENT && nPatternUnits == QtSvg::UnitTypes::userSpaceOnUse)
+        nx = (nx / 100.) * handler->document()->viewBox().width();
+    else if (type == QSvgHandler::LT_PERCENT)
+        nx = nx / 100.;
+
+    qreal ny = parseLength(y.toString(), &type, handler, &ok);
+    ny = convertToPixels(ny, true, type);
+    if (!ok)
+        ny = 0.0;
+    else if (type == QSvgHandler::LT_PERCENT && nPatternUnits == QtSvg::UnitTypes::userSpaceOnUse)
+        ny = (ny / 100.) * handler->document()->viewBox().height();
+    else if (type == QSvgHandler::LT_PERCENT)
+        ny = ny / 100.;
+
+    qreal nwidth = parseLength(width.toString(), &type, handler, &ok);
+    nwidth = convertToPixels(nwidth, true, type);
+    if (!ok)
+        nwidth = 0.0;
+    else if (type == QSvgHandler::LT_PERCENT && nPatternUnits == QtSvg::UnitTypes::userSpaceOnUse)
+        nwidth = (nwidth / 100.) * handler->document()->viewBox().width();
+    else if (type == QSvgHandler::LT_PERCENT)
+        nwidth = nwidth / 100.;
+
+    qreal nheight = parseLength(height.toString(), &type, handler, &ok);
+    nheight = convertToPixels(nheight, true, type);
+    if (!ok)
+        nheight = 0.0;
+    else if (type == QSvgHandler::LT_PERCENT && nPatternUnits == QtSvg::UnitTypes::userSpaceOnUse)
+        nheight = (nheight / 100.) * handler->document()->viewBox().height();
+    else if (type == QSvgHandler::LT_PERCENT)
+        nheight = nheight / 100.;
+
+
+    QStringList viewBoxValues;
+    QRectF viewBox;
+    if (!viewBoxStr.isEmpty()) {
+        viewBoxStr = viewBoxStr.replace(QLatin1Char(' '), QLatin1Char(','));
+        viewBoxStr = viewBoxStr.replace(QLatin1Char('\r'), QLatin1Char(','));
+        viewBoxStr = viewBoxStr.replace(QLatin1Char('\n'), QLatin1Char(','));
+        viewBoxStr = viewBoxStr.replace(QLatin1Char('\t'), QLatin1Char(','));
+        viewBoxValues = viewBoxStr.split(QLatin1Char(','), Qt::SkipEmptyParts);
+    }
+    if (viewBoxValues.size() == 4) {
+        QString xStr      = viewBoxValues.at(0).trimmed();
+        QString yStr      = viewBoxValues.at(1).trimmed();
+        QString widthStr  = viewBoxValues.at(2).trimmed();
+        QString heightStr = viewBoxValues.at(3).trimmed();
+
+        qreal x = convertToNumber(xStr, handler);
+        qreal y = convertToNumber(yStr, handler);
+        qreal w = convertToNumber(widthStr, handler);
+        qreal h = convertToNumber(heightStr, handler);
+
+        if (w > 0 && h > 0)
+            viewBox.setRect(x, y, w, h);
+    }
+
+    QTransform matrix;
+    if (!patternTransform.isEmpty())
+        matrix = parseTransformationMatrix(patternTransform);
+
+    QRectF bounds(nx, ny, nwidth, nheight);
+    if (bounds.isEmpty())
+        return nullptr;
+
+    QSvgRectF patternRectF(bounds, nPatternUnits, nPatternUnits, nPatternUnits, nPatternUnits);
+    QSvgPattern *node = new QSvgPattern(parent, patternRectF, viewBox, nPatternContentUnits, matrix);
+
+    // Create a style node for the Pattern.
+    QSvgPatternStyle *prop = new QSvgPatternStyle(node);
+    node->appendStyleProperty(prop, someId(attributes));
+
+    return node;
+}
+
 static bool parseTbreakNode(QSvgNode *parent,
                             const QXmlStreamAttributes &,
                             QSvgHandler *)
 {
-    if (parent->type() != QSvgNode::TEXTAREA)
+    if (parent->type() != QSvgNode::Textarea)
         return false;
     static_cast<QSvgText*>(parent)->addLineBreak();
     return true;
@@ -3296,9 +4130,9 @@ static QSvgNode *createTextNode(QSvgNode *parent,
     const QStringView y = attributes.value(QLatin1String("y"));
     //### editable and rotate not handled
     QSvgHandler::LengthType type;
-    qreal nx = parseLength(x.toString(), type, handler);
+    qreal nx = parseLength(x.toString(), &type, handler);
     nx = convertToPixels(nx, true, type);
-    qreal ny = parseLength(y.toString(), type, handler);
+    qreal ny = parseLength(y.toString(), &type, handler);
     ny = convertToPixels(ny, true, type);
 
     QSvgNode *text = new QSvgText(parent, QPointF(nx, ny));
@@ -3312,8 +4146,8 @@ static QSvgNode *createTextAreaNode(QSvgNode *parent,
     QSvgText *node = static_cast<QSvgText *>(createTextNode(parent, attributes, handler));
     if (node) {
         QSvgHandler::LengthType type;
-        qreal width = parseLength(attributes.value(QLatin1String("width")), type, handler);
-        qreal height = parseLength(attributes.value(QLatin1String("height")), type, handler);
+        qreal width = parseLength(attributes.value(QLatin1String("width")), &type, handler);
+        qreal height = parseLength(attributes.value(QLatin1String("height")), &type, handler);
         node->setTextArea(QSizeF(width, height));
     }
     return node;
@@ -3326,14 +4160,6 @@ static QSvgNode *createTspanNode(QSvgNode *parent,
     return new QSvgTspan(parent);
 }
 
-static bool parseTitleNode(QSvgNode *parent,
-                           const QXmlStreamAttributes &attributes,
-                           QSvgHandler *)
-{
-    Q_UNUSED(parent); Q_UNUSED(attributes);
-    return true;
-}
-
 static QSvgNode *createUseNode(QSvgNode *parent,
                                const QXmlStreamAttributes &attributes,
                                QSvgHandler *handler)
@@ -3346,10 +4172,11 @@ static QSvgNode *createUseNode(QSvgNode *parent,
     if (linkId.isEmpty())
         linkId = attributes.value(QLatin1String("href")).toString().remove(0, 1);
     switch (parent->type()) {
-    case QSvgNode::DOC:
-    case QSvgNode::DEFS:
-    case QSvgNode::G:
-    case QSvgNode::SWITCH:
+    case QSvgNode::Doc:
+    case QSvgNode::Defs:
+    case QSvgNode::Group:
+    case QSvgNode::Switch:
+    case QSvgNode::Mask:
         group = static_cast<QSvgStructureNode*>(parent);
         break;
     default:
@@ -3360,10 +4187,10 @@ static QSvgNode *createUseNode(QSvgNode *parent,
         QPointF pt;
         if (!xStr.isNull() || !yStr.isNull()) {
             QSvgHandler::LengthType type;
-            qreal nx = parseLength(xStr.toString(), type, handler);
+            qreal nx = parseLength(xStr.toString(), &type, handler);
             nx = convertToPixels(nx, true, type);
 
-            qreal ny = parseLength(yStr.toString(), type, handler);
+            qreal ny = parseLength(yStr.toString(), &type, handler);
             ny = convertToPixels(ny, true, type);
             pt = QPointF(nx, ny);
         }
@@ -3394,7 +4221,7 @@ static QSvgNode *createVideoNode(QSvgNode *parent,
 
 typedef QSvgNode *(*FactoryMethod)(QSvgNode *, const QXmlStreamAttributes &, QSvgHandler *);
 
-static FactoryMethod findGroupFactory(const QString &name)
+static FactoryMethod findGroupFactory(const QString &name, QtSvg::Options options)
 {
     if (name.isEmpty())
         return 0;
@@ -3404,12 +4231,23 @@ static FactoryMethod findGroupFactory(const QString &name)
     case 'd':
         if (ref == QLatin1String("efs")) return createDefsNode;
         break;
+    case 'f':
+        if (ref == QLatin1String("ilter") && !options.testFlag(QtSvg::Tiny12FeaturesOnly)) return createFilterNode;
+        break;
     case 'g':
         if (ref.isEmpty()) return createGNode;
         break;
+    case 'm':
+        if (ref == QLatin1String("ask") && !options.testFlag(QtSvg::Tiny12FeaturesOnly)) return createMaskNode;
+        if (ref == QLatin1String("arker") && !options.testFlag(QtSvg::Tiny12FeaturesOnly)) return createMarkerNode;
+        break;
     case 's':
         if (ref == QLatin1String("vg")) return createSvgNode;
         if (ref == QLatin1String("witch")) return createSwitchNode;
+        if (ref == QLatin1String("ymbol") && !options.testFlag(QtSvg::Tiny12FeaturesOnly)) return createSymbolNode;
+        break;
+    case 'p':
+        if (ref == QLatin1String("attern") && !options.testFlag(QtSvg::Tiny12FeaturesOnly)) return createPatternNode;
         break;
     default:
         break;
@@ -3417,8 +4255,9 @@ static FactoryMethod findGroupFactory(const QString &name)
     return 0;
 }
 
-static FactoryMethod findGraphicsFactory(const QString &name)
+static FactoryMethod findGraphicsFactory(const QString &name, QtSvg::Options options)
 {
+    Q_UNUSED(options);
     if (name.isEmpty())
         return 0;
 
@@ -3464,9 +4303,31 @@ static FactoryMethod findGraphicsFactory(const QString &name)
     return 0;
 }
 
+static FactoryMethod findFilterFtory(const QString &name, QtSvg::Options options)
+{
+    if (options.testFlag(QtSvg::Tiny12FeaturesOnly))
+        return 0;
+
+    if (name.isEmpty())
+        return 0;
+
+    if (!name.startsWith(QLatin1String("fe")))
+        return 0;
+
+    if (name == QLatin1String("feMerge")) return createFeMergeNode;
+    if (name == QLatin1String("feColorMatrix")) return createFeColorMatrixNode;
+    if (name == QLatin1String("feGaussianBlur")) return createFeGaussianBlurNode;
+    if (name == QLatin1String("feOffset")) return createFeOffsetNode;
+    if (name == QLatin1String("feMergeNode")) return createFeMergeNodeNode;
+    if (name == QLatin1String("feComposite")) return createFeCompositeNode;
+    if (name == QLatin1String("feFlood")) return createFeFloodNode;
+
+    return 0;
+}
+
 typedef bool (*ParseMethod)(QSvgNode *, const QXmlStreamAttributes &, QSvgHandler *);
 
-static ParseMethod findUtilFactory(const QString &name)
+static ParseMethod findUtilFactory(const QString &name, QtSvg::Options options)
 {
     if (name.isEmpty())
         return 0;
@@ -3482,7 +4343,6 @@ static ParseMethod findUtilFactory(const QString &name)
         if (ref == QLatin1String("udio")) return parseAudioNode;
         break;
     case 'd':
-        if (ref == QLatin1String("esc")) return parseDescNode;
         if (ref == QLatin1String("iscard")) return parseDiscardNode;
         break;
     case 'f':
@@ -3495,6 +4355,8 @@ static ParseMethod findUtilFactory(const QString &name)
     case 'm':
         if (ref == QLatin1String("etadata")) return parseMetadataNode;
         if (ref == QLatin1String("path")) return parseMpathNode;
+        if (ref == QLatin1String("ask") && !options.testFlag(QtSvg::Tiny12FeaturesOnly)) return parseMaskNode;
+        if (ref == QLatin1String("arker") && !options.testFlag(QtSvg::Tiny12FeaturesOnly)) return parseMarkerNode;
         break;
     case 'p':
         if (ref == QLatin1String("refetch")) return parsePrefetchNode;
@@ -3506,7 +4368,6 @@ static ParseMethod findUtilFactory(const QString &name)
         break;
     case 't':
         if (ref == QLatin1String("break")) return parseTbreakNode;
-        if (ref == QLatin1String("itle")) return parseTitleNode;
         break;
     default:
         break;
@@ -3575,20 +4436,26 @@ static StyleParseMethod findStyleUtilFactoryMethod(const QString &name)
     return 0;
 }
 
-QSvgHandler::QSvgHandler(QIODevice *device) : xml(new QXmlStreamReader(device))
-                                             , m_ownsReader(true)
+QSvgHandler::QSvgHandler(QIODevice *device, QtSvg::Options options)
+    : xml(new QXmlStreamReader(device))
+    , m_ownsReader(true)
+    , m_options(options)
 {
     init();
 }
 
-QSvgHandler::QSvgHandler(const QByteArray &data) : xml(new QXmlStreamReader(data))
-                                                 , m_ownsReader(true)
+QSvgHandler::QSvgHandler(const QByteArray &data, QtSvg::Options options)
+    : xml(new QXmlStreamReader(data))
+    , m_ownsReader(true)
+    , m_options(options)
 {
     init();
 }
 
-QSvgHandler::QSvgHandler(QXmlStreamReader *const reader) : xml(reader)
-                                                         , m_ownsReader(false)
+QSvgHandler::QSvgHandler(QXmlStreamReader *const reader, QtSvg::Options options)
+    : xml(reader)
+    , m_ownsReader(false)
+    , m_options(options)
 {
     init();
 }
@@ -3604,14 +4471,40 @@ void QSvgHandler::init()
     parse();
 }
 
-static bool detectCycles(const QSvgNode *node, QList<const QSvgUse *> active = {})
+static bool detectPatternCycles(const QSvgNode *node, QList<const QSvgNode *> active = {})
+{
+    QSvgFillStyle *fillStyle = static_cast<QSvgFillStyle*>
+        (node->styleProperty(QSvgStyleProperty::FILL));
+    if (fillStyle && fillStyle->style() && fillStyle->style()->type() == QSvgStyleProperty::PATTERN) {
+        QSvgPatternStyle *patternStyle = static_cast<QSvgPatternStyle *>(fillStyle->style());
+        if (active.contains(patternStyle->patternNode()))
+            return true;
+    }
+
+    QSvgStrokeStyle *strokeStyle = static_cast<QSvgStrokeStyle*>
+        (node->styleProperty(QSvgStyleProperty::STROKE));
+    if (strokeStyle && strokeStyle->style() && strokeStyle->style()->type() == QSvgStyleProperty::PATTERN) {
+        QSvgPatternStyle *patternStyle = static_cast<QSvgPatternStyle *>(strokeStyle->style());
+        if (active.contains(patternStyle->patternNode()))
+            return true;
+    }
+
+    return false;
+}
+
+static bool detectCycles(const QSvgNode *node, QList<const QSvgNode *> active = {})
 {
     if (Q_UNLIKELY(!node))
         return false;
     switch (node->type()) {
-    case QSvgNode::DOC:
-    case QSvgNode::G:
+    case QSvgNode::Doc:
+    case QSvgNode::Group:
+    case QSvgNode::Defs:
+    case QSvgNode::Pattern:
     {
+        if (node->type() == QSvgNode::Pattern)
+            active.append(node);
+
         auto *g = static_cast<const QSvgStructureNode*>(node);
         for (auto *r : g->renderers()) {
             if (detectCycles(r, active))
@@ -3619,7 +4512,7 @@ static bool detectCycles(const QSvgNode *node, QList<const QSvgUse *> active = {
         }
     }
     break;
-    case QSvgNode::USE:
+    case QSvgNode::Use:
     {
         if (active.contains(node))
             return true;
@@ -3633,6 +4526,17 @@ static bool detectCycles(const QSvgNode *node, QList<const QSvgUse *> active = {
         }
     }
     break;
+    case QSvgNode::Rect:
+    case QSvgNode::Ellipse:
+    case QSvgNode::Circle:
+    case QSvgNode::Line:
+    case QSvgNode::Path:
+    case QSvgNode::Polygon:
+    case QSvgNode::Polyline:
+    case QSvgNode::Tspan:
+        if (detectPatternCycles(node, active))
+            return true;
+        break;
     default:
         break;
     }
@@ -3673,9 +4577,8 @@ void QSvgHandler::parse()
             }
             break;
         case QXmlStreamReader::EndElement:
-            endElement(xml->name());
+            done = endElement(xml->name());
             ++remainingUnfinishedElements;
-            done = (xml->name() == QLatin1String("svg"));
             break;
         case QXmlStreamReader::Characters:
             characters(xml->text());
@@ -3687,7 +4590,7 @@ void QSvgHandler::parse()
             break;
         }
     }
-    resolveGradients(m_doc);
+    resolvePaintServers(m_doc);
     resolveNodes();
     if (detectCycles(m_doc)) {
         qCWarning(lcSvgHandler, "Cycles detected in SVG, document discarded.");
@@ -3725,52 +4628,72 @@ bool QSvgHandler::startElement(const QString &localName,
     if (!m_doc && localName != QLatin1String("svg"))
         return false;
 
-    if (FactoryMethod method = findGroupFactory(localName)) {
+    if (m_doc && localName == QLatin1String("svg")) {
+        m_skipNodes.push(Doc);
+        qCWarning(lcSvgHandler) << "Skipping a nested svg element, because "
+                                   "SVG Document must not contain nested svg elements in Svg Tiny 1.2";
+    }
+
+    if (!m_skipNodes.isEmpty() && m_skipNodes.top() == Doc)
+        return true;
+
+    if (FactoryMethod method = findGroupFactory(localName, options())) {
         //group
         node = method(m_doc ? m_nodes.top() : 0, attributes, this);
-        Q_ASSERT(node);
-        if (!m_doc) {
-            Q_ASSERT(node->type() == QSvgNode::DOC);
-            m_doc = static_cast<QSvgTinyDocument*>(node);
-        } else {
-            switch (m_nodes.top()->type()) {
-            case QSvgNode::DOC:
-            case QSvgNode::G:
-            case QSvgNode::DEFS:
-            case QSvgNode::SWITCH:
-            {
-                QSvgStructureNode *group =
-                    static_cast<QSvgStructureNode*>(m_nodes.top());
-                group->addChild(node, someId(attributes));
-            }
-                break;
-            default:
-                const QByteArray msg = QByteArrayLiteral("Could not add child element to parent element because the types are incorrect.");
-                qCWarning(lcSvgHandler, "%s", prefixMessage(msg, xml).constData());
-                delete node;
-                node = 0;
-                break;
-            }
-        }
+
         if (node) {
-            parseCoreNode(node, attributes);
+            if (!m_doc) {
+                Q_ASSERT(node->type() == QSvgNode::Doc);
+                m_doc = static_cast<QSvgTinyDocument*>(node);
+            } else {
+                switch (m_nodes.top()->type()) {
+                case QSvgNode::Doc:
+                case QSvgNode::Group:
+                case QSvgNode::Defs:
+                case QSvgNode::Switch:
+                case QSvgNode::Mask:
+                case QSvgNode::Symbol:
+                case QSvgNode::Marker:
+                case QSvgNode::Pattern:
+                {
+                    QSvgStructureNode *group =
+                        static_cast<QSvgStructureNode*>(m_nodes.top());
+                    group->addChild(node, someId(attributes));
+                }
+                    break;
+                default:
+                    const QByteArray msg = QByteArrayLiteral("Could not add child element to parent element because the types are incorrect.");
+                    qCWarning(lcSvgHandler, "%s", prefixMessage(msg, xml).constData());
+                    delete node;
+                    node = 0;
+                    break;
+                }
+            }
+
+            if (node) {
+                parseCoreNode(node, attributes);
 #ifndef QT_NO_CSSPARSER
-            cssStyleLookup(node, this, m_selector);
+                cssStyleLookup(node, this, m_selector);
 #endif
-            parseStyle(node, attributes, this);
+                parseStyle(node, attributes, this);
+            }
         }
-    } else if (FactoryMethod method = findGraphicsFactory(localName)) {
+    } else if (FactoryMethod method = findGraphicsFactory(localName, options())) {
         //rendering element
         Q_ASSERT(!m_nodes.isEmpty());
         node = method(m_nodes.top(), attributes, this);
         if (node) {
             switch (m_nodes.top()->type()) {
-            case QSvgNode::DOC:
-            case QSvgNode::G:
-            case QSvgNode::DEFS:
-            case QSvgNode::SWITCH:
+            case QSvgNode::Doc:
+            case QSvgNode::Group:
+            case QSvgNode::Defs:
+            case QSvgNode::Switch:
+            case QSvgNode::Mask:
+            case QSvgNode::Symbol:
+            case QSvgNode::Marker:
+            case QSvgNode::Pattern:
             {
-                if (node->type() == QSvgNode::TSPAN) {
+                if (node->type() == QSvgNode::Tspan) {
                     const QByteArray msg = QByteArrayLiteral("\'tspan\' element in wrong context.");
                     qCWarning(lcSvgHandler, "%s", prefixMessage(msg, xml).constData());
                     delete node;
@@ -3782,9 +4705,9 @@ bool QSvgHandler::startElement(const QString &localName,
                 group->addChild(node, someId(attributes));
             }
                 break;
-            case QSvgNode::TEXT:
-            case QSvgNode::TEXTAREA:
-                if (node->type() == QSvgNode::TSPAN) {
+            case QSvgNode::Text:
+            case QSvgNode::Textarea:
+                if (node->type() == QSvgNode::Tspan) {
                     static_cast<QSvgText *>(m_nodes.top())->addTspan(static_cast<QSvgTspan *>(node));
                 } else {
                     const QByteArray msg = QByteArrayLiteral("\'text\' or \'textArea\' element contains invalid element type.");
@@ -3807,18 +4730,35 @@ bool QSvgHandler::startElement(const QString &localName,
                 cssStyleLookup(node, this, m_selector);
 #endif
                 parseStyle(node, attributes, this);
-                if (node->type() == QSvgNode::TEXT || node->type() == QSvgNode::TEXTAREA) {
+                if (node->type() == QSvgNode::Text || node->type() == QSvgNode::Textarea) {
                     static_cast<QSvgText *>(node)->setWhitespaceMode(m_whitespaceMode.top());
-                } else if (node->type() == QSvgNode::TSPAN) {
+                } else if (node->type() == QSvgNode::Tspan) {
                     static_cast<QSvgTspan *>(node)->setWhitespaceMode(m_whitespaceMode.top());
-                } else if (node->type() == QSvgNode::USE) {
+                } else if (node->type() == QSvgNode::Use) {
                     auto useNode = static_cast<QSvgUse *>(node);
                     if (!useNode->isResolved())
                         m_toBeResolved.append(useNode);
                 }
             }
         }
-    } else if (ParseMethod method = findUtilFactory(localName)) {
+    } else if (FactoryMethod method = findFilterFtory(localName, options())) {
+        //filter nodes to be aded to be filtercontainer
+        Q_ASSERT(!m_nodes.isEmpty());
+        node = method(m_nodes.top(), attributes, this);
+        if (node) {
+            if (m_nodes.top()->type() == QSvgNode::Filter ||
+                (m_nodes.top()->type() == QSvgNode::FeMerge && node->type() == QSvgNode::FeMergenode)) {
+                QSvgStructureNode *container =
+                    static_cast<QSvgStructureNode*>(m_nodes.top());
+                container->addChild(node, someId(attributes));
+            } else {
+                const QByteArray msg = QByteArrayLiteral("Could not add child element to parent element because the types are incorrect.");
+                qCWarning(lcSvgHandler, "%s", prefixMessage(msg, xml).constData());
+                delete node;
+                node = 0;
+            }
+        }
+    } else if (ParseMethod method = findUtilFactory(localName, options())) {
         Q_ASSERT(!m_nodes.isEmpty());
         if (!method(m_nodes.top(), attributes, this))
             qCWarning(lcSvgHandler, "%s", msgProblemParsing(localName, xml).constData());
@@ -3837,7 +4777,7 @@ bool QSvgHandler::startElement(const QString &localName,
                 qCWarning(lcSvgHandler, "%s", msgProblemParsing(localName, xml).constData());
         }
     } else {
-        //qCWarning(lcSvgHandler) <<"Skipping unknown element!"<<namespaceURI<<"::"<<localName;
+        qCDebug(lcSvgHandler) << "Skipping unknown element" << localName;
         m_skipNodes.push(Unknown);
         return true;
     }
@@ -3855,14 +4795,17 @@ bool QSvgHandler::startElement(const QString &localName,
 bool QSvgHandler::endElement(const QStringView localName)
 {
     CurrentNode node = m_skipNodes.top();
+
+    if (node == Doc && localName != QLatin1String("svg"))
+        return false;
+
     m_skipNodes.pop();
     m_whitespaceMode.pop();
 
     popColor();
 
-    if (node == Unknown) {
-        return true;
-    }
+    if (node == Unknown)
+        return false;
 
 #ifdef QT_NO_CSSPARSER
     Q_UNUSED(localName);
@@ -3876,13 +4819,13 @@ bool QSvgHandler::endElement(const QStringView localName)
     else if (m_style && !m_skipNodes.isEmpty() && m_skipNodes.top() != Style)
         m_style = 0;
 
-    return true;
+    return ((localName == QLatin1String("svg")) && (node != Doc));
 }
 
-void QSvgHandler::resolveGradients(QSvgNode *node, int nestedDepth)
+void QSvgHandler::resolvePaintServers(QSvgNode *node, int nestedDepth)
 {
-    if (!node || (node->type() != QSvgNode::DOC && node->type() != QSvgNode::G
-        && node->type() != QSvgNode::DEFS && node->type() != QSvgNode::SWITCH)) {
+    if (!node || (node->type() != QSvgNode::Doc && node->type() != QSvgNode::Group
+        && node->type() != QSvgNode::Defs && node->type() != QSvgNode::Switch)) {
         return;
     }
 
@@ -3891,9 +4834,9 @@ void QSvgHandler::resolveGradients(QSvgNode *node, int nestedDepth)
     const QList<QSvgNode *> ren = structureNode->renderers();
     for (auto it = ren.begin(); it != ren.end(); ++it) {
         QSvgFillStyle *fill = static_cast<QSvgFillStyle *>((*it)->styleProperty(QSvgStyleProperty::FILL));
-        if (fill && !fill->isGradientResolved()) {
-            QString id = fill->gradientId();
-            QSvgFillStyleProperty *style = structureNode->styleProperty(id);
+        if (fill && !fill->isPaintStyleResolved()) {
+            QString id = fill->paintStyleId();
+            QSvgPaintStyleProperty *style = structureNode->styleProperty(id);
             if (style) {
                 fill->setFillStyle(style);
             } else {
@@ -3903,9 +4846,9 @@ void QSvgHandler::resolveGradients(QSvgNode *node, int nestedDepth)
         }
 
         QSvgStrokeStyle *stroke = static_cast<QSvgStrokeStyle *>((*it)->styleProperty(QSvgStyleProperty::STROKE));
-        if (stroke && !stroke->isGradientResolved()) {
-            QString id = stroke->gradientId();
-            QSvgFillStyleProperty *style = structureNode->styleProperty(id);
+        if (stroke && !stroke->isPaintStyleResolved()) {
+            QString id = stroke->paintStyleId();
+            QSvgPaintStyleProperty *style = structureNode->styleProperty(id);
             if (style) {
                 stroke->setStyle(style);
             } else {
@@ -3915,7 +4858,7 @@ void QSvgHandler::resolveGradients(QSvgNode *node, int nestedDepth)
         }
 
         if (nestedDepth < 2048)
-            resolveGradients(*it, nestedDepth + 1);
+            resolvePaintServers(*it, nestedDepth + 1);
     }
 }
 
@@ -3927,7 +4870,7 @@ void QSvgHandler::resolveNodes()
             continue;
 
         QSvgNode::Type t = parent->type();
-        if (t != QSvgNode::DOC && t != QSvgNode::DEFS && t != QSvgNode::G && t != QSvgNode::SWITCH)
+        if (t != QSvgNode::Doc && t != QSvgNode::Defs && t != QSvgNode::Group && t != QSvgNode::Switch)
             continue;
 
         QSvgStructureNode *group = static_cast<QSvgStructureNode *>(parent);
@@ -3959,9 +4902,9 @@ bool QSvgHandler::characters(const QStringView str)
     if (m_skipNodes.isEmpty() || m_skipNodes.top() == Unknown || m_nodes.isEmpty())
         return true;
 
-    if (m_nodes.top()->type() == QSvgNode::TEXT || m_nodes.top()->type() == QSvgNode::TEXTAREA) {
+    if (m_nodes.top()->type() == QSvgNode::Text || m_nodes.top()->type() == QSvgNode::Textarea) {
         static_cast<QSvgText*>(m_nodes.top())->addText(str.toString());
-    } else if (m_nodes.top()->type() == QSvgNode::TSPAN) {
+    } else if (m_nodes.top()->type() == QSvgNode::Tspan) {
         static_cast<QSvgTspan*>(m_nodes.top())->addText(str.toString());
     }
 
diff --git a/src/svg/qsvghandler_p.h b/src/svg/qsvghandler_p.h
index ac24e16..2857ac0 100644
--- a/src/svg/qsvghandler_p.h
+++ b/src/svg/qsvghandler_p.h
@@ -44,7 +44,7 @@ struct QSvgCssAttribute
 
 #endif
 
-class Q_SVG_PRIVATE_EXPORT QSvgHandler
+class Q_SVG_EXPORT QSvgHandler
 {
 public:
     enum LengthType {
@@ -59,9 +59,9 @@ public:
     };
 
 public:
-    QSvgHandler(QIODevice *device);
-    QSvgHandler(const QByteArray &data);
-    QSvgHandler(QXmlStreamReader *const data);
+    QSvgHandler(QIODevice *device, QtSvg::Options options = {});
+    QSvgHandler(const QByteArray &data, QtSvg::Options options = {});
+    QSvgHandler(QXmlStreamReader *const data, QtSvg::Options options = {});
     ~QSvgHandler();
 
     QIODevice *device() const;
@@ -99,6 +99,9 @@ public:
     inline QPen defaultPen() const
     { return m_defaultPen; }
 
+    QtSvg::Options options() const;
+    bool trustedSourceMode() const;
+
 public:
     bool startElement(const QString &localName, const QXmlStreamAttributes &attributes);
     bool endElement(QStringView localName);
@@ -118,7 +121,8 @@ private:
     {
         Unknown,
         Graphics,
-        Style
+        Style,
+        Doc
     };
     QStack<CurrentNode> m_skipNodes;
 
@@ -144,7 +148,7 @@ private:
     QCss::Parser m_cssParser;
 #endif
     void parse();
-    void resolveGradients(QSvgNode *node, int nestedDepth = 0);
+    void resolvePaintServers(QSvgNode *node, int nestedDepth = 0);
     void resolveNodes();
 
     QPen m_defaultPen;
@@ -153,6 +157,8 @@ private:
      * we need to delete it.
      */
     const bool m_ownsReader;
+
+    const QtSvg::Options m_options;
 };
 
 Q_DECLARE_LOGGING_CATEGORY(lcSvgHandler)
diff --git a/src/svg/qsvghelper_p.h b/src/svg/qsvghelper_p.h
new file mode 100644
index 0000000..832bf7f
--- /dev/null
+++ b/src/svg/qsvghelper_p.h
@@ -0,0 +1,123 @@
+// Copyright (C) 2023 The Qt Company Ltd.
+// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
+
+#ifndef QSVGHELPER_P_H
+#define QSVGHELPER_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qtsvgglobal_p.h"
+
+#include <QRectF>
+
+QT_BEGIN_NAMESPACE
+
+class Q_SVG_EXPORT QSvgRectF : public QRectF
+{
+public:
+    QSvgRectF(const QRectF &r = QRectF(),
+              QtSvg::UnitTypes unitX = QtSvg::UnitTypes::userSpaceOnUse,
+              QtSvg::UnitTypes unitY = QtSvg::UnitTypes::userSpaceOnUse,
+              QtSvg::UnitTypes unitW = QtSvg::UnitTypes::userSpaceOnUse,
+              QtSvg::UnitTypes unitH = QtSvg::UnitTypes::userSpaceOnUse)
+        : QRectF(r)
+        , m_unitX(unitX)
+        , m_unitY(unitY)
+        , m_unitW(unitW)
+        , m_unitH(unitH)
+    {}
+
+    QRectF combinedWithLocalRect(const QRectF &localRect) const {
+        QRectF result;
+        if (m_unitX == QtSvg::UnitTypes::objectBoundingBox)
+            result.setX(localRect.x() + x() * localRect.width());
+        else
+            result.setX(x());
+        if (m_unitY == QtSvg::UnitTypes::objectBoundingBox)
+            result.setY(localRect.y() + y() * localRect.height());
+        else
+            result.setY(y());
+        if (m_unitW == QtSvg::UnitTypes::objectBoundingBox)
+            result.setWidth(localRect.width() * width());
+        else
+            result.setWidth(width());
+        if (m_unitH == QtSvg::UnitTypes::objectBoundingBox)
+            result.setHeight(localRect.height() * height());
+        else
+            result.setHeight(height());
+        return result;
+    }
+
+    QPointF translationRelativeToBoundingBox(const QRectF &boundingBox) const {
+        QPointF result;
+
+        if (m_unitX == QtSvg::UnitTypes::objectBoundingBox)
+            result.setX(x() * boundingBox.width());
+        else
+            result.setX(x());
+        if (m_unitY == QtSvg::UnitTypes::objectBoundingBox)
+            result.setY(y() * boundingBox.height());
+        else
+            result.setY(y());
+        return result;
+    }
+
+    QRectF combinedWithLocalRect(const QRectF &localRect, const QRectF &canvasRect, QtSvg::UnitTypes units) const {
+        QRectF result;
+        if (units == QtSvg::UnitTypes::objectBoundingBox)
+            result.setX(localRect.x() + x() * localRect.width());
+        else if (m_unitX == QtSvg::UnitTypes::objectBoundingBox)
+            result.setX(canvasRect.x() + x() * canvasRect.width());
+        else
+            result.setX(x());
+        if (units == QtSvg::UnitTypes::objectBoundingBox)
+            result.setY(localRect.y() + y() * localRect.height());
+        else if (m_unitY == QtSvg::UnitTypes::objectBoundingBox)
+            result.setY(canvasRect.y() + y() * canvasRect.height());
+        else
+            result.setY(y());
+        if (units == QtSvg::UnitTypes::objectBoundingBox)
+            result.setWidth(localRect.width() * width());
+        else if (m_unitW == QtSvg::UnitTypes::objectBoundingBox)
+            result.setWidth(canvasRect.width() * width());
+        else
+            result.setWidth(width());
+        if (units == QtSvg::UnitTypes::objectBoundingBox)
+            result.setHeight(localRect.height() * height());
+        else if (m_unitH == QtSvg::UnitTypes::objectBoundingBox)
+            result.setHeight(canvasRect.height() * height());
+        else
+            result.setHeight(height());
+
+        return result;
+    }
+
+    QtSvg::UnitTypes unitX() const {return m_unitX;}
+    QtSvg::UnitTypes unitY() const {return m_unitY;}
+    QtSvg::UnitTypes unitW() const {return m_unitW;}
+    QtSvg::UnitTypes unitH() const {return m_unitH;}
+
+    void setUnitX(QtSvg::UnitTypes unit) {m_unitX = unit;}
+    void setUnitY(QtSvg::UnitTypes unit) {m_unitY = unit;}
+    void setUnitW(QtSvg::UnitTypes unit) {m_unitW = unit;}
+    void setUnitH(QtSvg::UnitTypes unit) {m_unitH = unit;}
+
+protected:
+    QtSvg::UnitTypes m_unitX,
+                     m_unitY,
+                     m_unitW,
+                     m_unitH;
+};
+
+QT_END_NAMESPACE
+
+#endif // QSVGHELPER_P_H
diff --git a/src/svg/qsvgnode.cpp b/src/svg/qsvgnode.cpp
index 31e5338..8ad2240 100644
--- a/src/svg/qsvgnode.cpp
+++ b/src/svg/qsvgnode.cpp
@@ -5,20 +5,24 @@
 #include "qsvgtinydocument_p.h"
 
 #include <QLoggingCategory>
+#include<QElapsedTimer>
+#include <QtGui/qimageiohandler.h>
 
 #include "qdebug.h"
 #include "qstack.h"
 
 #include <QtGui/private/qoutlinemapper_p.h>
 
+QT_BEGIN_NAMESPACE
+
+Q_DECLARE_LOGGING_CATEGORY(lcSvgDraw);
+
+Q_LOGGING_CATEGORY(lcSvgTiming, "qt.svg.timing")
+
 #if !defined(QT_SVG_SIZE_LIMIT)
 #  define QT_SVG_SIZE_LIMIT QT_RASTER_COORD_LIMIT
 #endif
 
-QT_BEGIN_NAMESPACE
-
-Q_DECLARE_LOGGING_CATEGORY(lcSvgDraw)
-
 QSvgNode::QSvgNode(QSvgNode *parent)
     : m_parent(parent),
       m_visible(true),
@@ -31,6 +35,128 @@ QSvgNode::~QSvgNode()
 
 }
 
+void QSvgNode::draw(QPainter *p, QSvgExtraStates &states)
+{
+#ifndef QT_NO_DEBUG
+    QElapsedTimer qtSvgTimer; qtSvgTimer.start();
+#endif
+
+    if (shouldDrawNode(p, states)) {
+        applyStyle(p, states);
+        QSvgNode *maskNode = this->hasMask() ? document()->namedNode(this->maskId()) : nullptr;
+        QSvgNode *filterNode = this->hasFilter() ? document()->namedNode(this->filterId()) : nullptr;
+        if (filterNode && filterNode->type() == QSvgNode::Filter) {
+            QTransform xf = p->transform();
+            p->resetTransform();
+            QRectF localRect = bounds(p, states);
+            QRectF boundsRect = xf.mapRect(localRect);
+            p->setTransform(xf);
+            QImage proxy = drawIntoBuffer(p, states, boundsRect.toRect());
+            proxy = static_cast<QSvgFilterContainer*>(filterNode)->applyFilter(this, proxy, p, localRect);
+
+            boundsRect = QRectF(proxy.offset(), proxy.size());
+            localRect = p->transform().inverted().mapRect(boundsRect);
+            if (maskNode && maskNode->type() == QSvgNode::Mask) {
+                QImage mask = static_cast<QSvgMask*>(maskNode)->createMask(p, states, localRect, &boundsRect);
+                applyMaskToBuffer(&proxy, mask);
+            }
+            applyBufferToCanvas(p, proxy);
+
+        } else if (maskNode && maskNode->type() == QSvgNode::Mask) {
+            QRectF boundsRect;
+            QImage mask = static_cast<QSvgMask*>(maskNode)->createMask(p, states, this, &boundsRect);
+            drawWithMask(p, states, mask, boundsRect.toRect());
+        } else {
+            if (separateFillStroke())
+                fillThenStroke(p, states);
+            else
+                drawCommand(p, states);
+        }
+        revertStyle(p, states);
+    }
+
+#ifndef QT_NO_DEBUG
+    if (Q_UNLIKELY(lcSvgTiming().isDebugEnabled()))
+        qCDebug(lcSvgTiming) << "Drawing" << typeName() << "took" << (qtSvgTimer.nsecsElapsed() / 1000000.0f) << "ms";
+#endif
+}
+
+void QSvgNode::fillThenStroke(QPainter *p, QSvgExtraStates &states)
+{
+    qreal oldOpacity = p->opacity();
+    if (p->brush().style() != Qt::NoBrush) {
+        QPen oldPen = p->pen();
+        p->setPen(Qt::NoPen);
+        p->setOpacity(oldOpacity * states.fillOpacity);
+
+        drawCommand(p, states);
+
+        p->setPen(oldPen);
+    }
+    if (p->pen() != Qt::NoPen && p->pen().brush() != Qt::NoBrush && p->pen().widthF() != 0) {
+        QBrush oldBrush = p->brush();
+        p->setOpacity(oldOpacity * states.strokeOpacity);
+        p->setBrush(Qt::NoBrush);
+
+        drawCommand(p, states);
+
+        p->setBrush(oldBrush);
+    }
+    p->setOpacity(oldOpacity);
+}
+
+void QSvgNode::drawWithMask(QPainter *p, QSvgExtraStates &states, const QImage &mask, const QRect &boundsRect)
+{
+    QImage proxy = drawIntoBuffer(p, states, boundsRect);
+    if (proxy.isNull())
+        return;
+    applyMaskToBuffer(&proxy, mask);
+
+    p->save();
+    p->resetTransform();
+    p->drawImage(boundsRect, proxy);
+    p->restore();
+}
+
+QImage QSvgNode::drawIntoBuffer(QPainter *p, QSvgExtraStates &states, const QRect &boundsRect)
+{
+    QImage proxy;
+    if (!QImageIOHandler::allocateImage(boundsRect.size(), QImage::Format_RGBA8888, &proxy)) {
+        qCWarning(lcSvgDraw) << "The requested buffer size is too big, ignoring";
+        return proxy;
+    }
+    proxy.setOffset(boundsRect.topLeft());
+    proxy.fill(Qt::transparent);
+    QPainter proxyPainter(&proxy);
+    proxyPainter.setPen(p->pen());
+    proxyPainter.setBrush(p->brush());
+    proxyPainter.setFont(p->font());
+    proxyPainter.translate(-boundsRect.topLeft());
+    proxyPainter.setTransform(p->transform(), true);
+    proxyPainter.setRenderHints(p->renderHints());
+    if (separateFillStroke())
+        fillThenStroke(&proxyPainter, states);
+    else
+        drawCommand(&proxyPainter, states);
+    return proxy;
+}
+
+void QSvgNode::applyMaskToBuffer(QImage *proxy, QImage mask) const
+{
+    QPainter proxyPainter(proxy);
+    proxyPainter.setCompositionMode(QPainter::CompositionMode_DestinationOut);
+    proxyPainter.resetTransform();
+    proxyPainter.drawImage(QRect(0, 0, mask.width(), mask.height()), mask);
+}
+
+void QSvgNode::applyBufferToCanvas(QPainter *p, QImage proxy) const
+{
+    QTransform xf = p->transform();
+    p->resetTransform();
+    p->drawImage(QRect(proxy.offset(), proxy.size()), proxy);
+    p->setTransform(xf);
+}
+
 bool QSvgNode::isDescendantOf(const QSvgNode *parent) const
 {
     const QSvgNode *n = this;
@@ -74,6 +200,12 @@ void QSvgNode::appendStyleProperty(QSvgStyleProperty *prop, const QString &id)
         if (doc && !id.isEmpty())
             doc->addNamedStyle(id, m_style.gradient);
         break;
+    case QSvgStyleProperty::PATTERN:
+        m_style.pattern = static_cast<QSvgPatternStyle*>(prop);
+        doc = document();
+        if (doc && !id.isEmpty())
+            doc->addNamedStyle(id, m_style.pattern);
+        break;
     case QSvgStyleProperty::TRANSFORM:
         m_style.transform = static_cast<QSvgTransformStyle*>(prop);
         break;
@@ -101,6 +233,22 @@ void QSvgNode::applyStyle(QPainter *p, QSvgExtraStates &states) const
     m_style.apply(p, this, states);
 }
 
+/*!
+    \internal
+
+    Apply the styles of all parents to the painter and the states.
+    The styles are applied from the top level node to the current node.
+    This function can be used to set the correct style for a node
+    if it's draw function is triggered out of the ordinary draw context,
+    for example the mask node, that is cross-referenced.
+*/
+void QSvgNode::applyStyleRecursive(QPainter *p, QSvgExtraStates &states) const
+{
+    if (parent())
+        parent()->applyStyleRecursive(p, states);
+    applyStyle(p, states);
+}
+
 void QSvgNode::revertStyle(QPainter *p, QSvgExtraStates &states) const
 {
     m_style.revert(p, states);
@@ -139,6 +287,10 @@ QSvgStyleProperty * QSvgNode::styleProperty(QSvgStyleProperty::Type type) const
             if (node->m_style.gradient)
                 return node->m_style.gradient;
             break;
+        case QSvgStyleProperty::PATTERN:
+            if (node->m_style.pattern)
+                return node->m_style.pattern;
+            break;
         case QSvgStyleProperty::TRANSFORM:
             if (node->m_style.transform)
                 return node->m_style.transform;
@@ -168,7 +320,7 @@ QSvgStyleProperty * QSvgNode::styleProperty(QSvgStyleProperty::Type type) const
     return 0;
 }
 
-QSvgFillStyleProperty * QSvgNode::styleProperty(const QString &id) const
+QSvgPaintStyleProperty * QSvgNode::styleProperty(const QString &id) const
 {
     QString rid = id;
     if (rid.startsWith(QLatin1Char('#')))
@@ -220,7 +372,7 @@ QSvgTinyDocument * QSvgNode::document() const
 {
     QSvgTinyDocument *doc = nullptr;
     QSvgNode *node = const_cast<QSvgNode*>(this);
-    while (node && node->type() != QSvgNode::DOC) {
+    while (node && node->type() != QSvgNode::Doc) {
         node = node->parent();
     }
     doc = static_cast<QSvgTinyDocument*>(node);
@@ -228,6 +380,43 @@ QSvgTinyDocument * QSvgNode::document() const
     return doc;
 }
 
+QString QSvgNode::typeName() const
+{
+    switch (type()) {
+        case Doc: return QStringLiteral("svg");
+        case Group: return QStringLiteral("g");
+        case Defs: return QStringLiteral("defs");
+        case Switch: return QStringLiteral("switch");
+        case Animation: return QStringLiteral("animation");
+        case Circle: return QStringLiteral("circle");
+        case Ellipse: return QStringLiteral("ellipse");
+        case Image: return QStringLiteral("image");
+        case Line: return QStringLiteral("line");
+        case Path: return QStringLiteral("path");
+        case Polygon: return QStringLiteral("polygon");
+        case Polyline: return QStringLiteral("polyline");
+        case Rect: return QStringLiteral("rect");
+        case Text: return QStringLiteral("text");
+        case Textarea: return QStringLiteral("textarea");
+        case Tspan: return QStringLiteral("tspan");
+        case Use: return QStringLiteral("use");
+        case Video: return QStringLiteral("video");
+        case Mask: return QStringLiteral("mask");
+        case Symbol: return QStringLiteral("symbol");
+        case Marker: return QStringLiteral("marker");
+        case Pattern: return QStringLiteral("pattern");
+        case Filter: return QStringLiteral("filter");
+        case FeMerge: return QStringLiteral("feMerge");
+        case FeMergenode: return QStringLiteral("feMergeNode");
+        case FeColormatrix: return QStringLiteral("feColorMatrix");
+        case FeGaussianblur: return QStringLiteral("feGaussianBlur");
+        case FeOffset: return QStringLiteral("feOffset");
+        case FeComposite: return QStringLiteral("feComposite");
+        case FeFlood: return QStringLiteral("feFlood");
+    }
+    return QStringLiteral("unknown");
+}
+
 void QSvgNode::setRequiredFeatures(const QStringList &lst)
 {
     m_requiredFeatures = lst;
@@ -308,6 +497,98 @@ void QSvgNode::setXmlClass(const QString &str)
     m_class = str;
 }
 
+QString QSvgNode::maskId() const
+{
+    return m_maskId;
+}
+
+void QSvgNode::setMaskId(const QString &str)
+{
+    m_maskId = str;
+}
+
+bool QSvgNode::hasMask() const
+{
+    if (document()->options().testFlag(QtSvg::Tiny12FeaturesOnly))
+        return false;
+    return !m_maskId.isEmpty();
+}
+
+QString QSvgNode::filterId() const
+{
+    return m_filterId;
+}
+
+void QSvgNode::setFilterId(const QString &str)
+{
+    m_filterId = str;
+}
+
+bool QSvgNode::hasFilter() const
+{
+    if (document()->options().testFlag(QtSvg::Tiny12FeaturesOnly))
+        return false;
+    return !m_filterId.isEmpty();
+}
+
+QString QSvgNode::markerStartId() const
+{
+    return m_markerStartId;
+}
+
+void QSvgNode::setMarkerStartId(const QString &str)
+{
+    m_markerStartId = str;
+}
+
+bool QSvgNode::hasMarkerStart() const
+{
+    if (document()->options().testFlag(QtSvg::Tiny12FeaturesOnly))
+        return false;
+    return !m_markerStartId.isEmpty();
+}
+
+QString QSvgNode::markerMidId() const
+{
+    return m_markerMidId;
+}
+
+void QSvgNode::setMarkerMidId(const QString &str)
+{
+    m_markerMidId = str;
+}
+
+bool QSvgNode::hasMarkerMid() const
+{
+    if (document()->options().testFlag(QtSvg::Tiny12FeaturesOnly))
+        return false;
+    return !m_markerMidId.isEmpty();
+}
+
+QString QSvgNode::markerEndId() const
+{
+    return m_markerEndId;
+}
+
+void QSvgNode::setMarkerEndId(const QString &str)
+{
+    m_markerEndId = str;
+}
+
+bool QSvgNode::hasMarkerEnd() const
+{
+    if (document()->options().testFlag(QtSvg::Tiny12FeaturesOnly))
+        return false;
+    return !m_markerEndId.isEmpty();
+}
+
+bool QSvgNode::hasAnyMarker() const
+{
+    if (document()->options().testFlag(QtSvg::Tiny12FeaturesOnly))
+        return false;
+    return hasMarkerStart() || hasMarkerMid() || hasMarkerEnd();
+}
+
 void QSvgNode::setDisplayMode(DisplayMode mode)
 {
     m_displayMode = mode;
@@ -326,9 +607,27 @@ qreal QSvgNode::strokeWidth(QPainter *p)
     return pen.widthF();
 }
 
+void QSvgNode::initPainter(QPainter *p)
+{
+    QPen pen(Qt::NoBrush, 1, Qt::SolidLine, Qt::FlatCap, Qt::SvgMiterJoin);
+    pen.setMiterLimit(4);
+    p->setPen(pen);
+    p->setBrush(Qt::black);
+    p->setRenderHint(QPainter::Antialiasing);
+    p->setRenderHint(QPainter::SmoothPixmapTransform);
+    QFont font(p->font());
+    if (font.pointSize() < 0)
+        font.setPointSizeF(font.pixelSize() * 72.0 / p->device()->logicalDpiY());
+    p->setFont(font);
+}
+
 bool QSvgNode::shouldDrawNode(QPainter *p, QSvgExtraStates &states) const
 {
     static bool alwaysDraw = qEnvironmentVariableIntValue("QT_SVG_DISABLE_SIZE_LIMIT");
+
+    if (m_displayMode == DisplayMode::NoneMode)
+        return false;
+
     if (alwaysDraw)
         return true;
 
diff --git a/src/svg/qsvgnode_p.h b/src/svg/qsvgnode_p.h
index df9ef8a..f616a45 100644
--- a/src/svg/qsvgnode_p.h
+++ b/src/svg/qsvgnode_p.h
@@ -17,6 +17,7 @@
 
 #include "qsvgstyle_p.h"
 #include "qtsvgglobal_p.h"
+#include "qsvghelper_p.h"
 
 #include "QtCore/qstring.h"
 #include "QtCore/qhash.h"
@@ -26,30 +27,41 @@ QT_BEGIN_NAMESPACE
 class QPainter;
 class QSvgTinyDocument;
 
-class Q_SVG_PRIVATE_EXPORT QSvgNode
+class Q_SVG_EXPORT QSvgNode
 {
 public:
     enum Type
     {
-        DOC,
-        G,
-        DEFS,
-        SWITCH,
-        ANIMATION,
-        ARC,
-        CIRCLE,
-        ELLIPSE,
-        IMAGE,
-        LINE,
-        PATH,
-        POLYGON,
-        POLYLINE,
-        RECT,
-        TEXT,
-        TEXTAREA,
-        TSPAN,
-        USE,
-        VIDEO
+        Doc,
+        Group,
+        Defs,
+        Switch,
+        Animation,
+        Circle,
+        Ellipse,
+        Image,
+        Line,
+        Path,
+        Polygon,
+        Polyline,
+        Rect,
+        Text,
+        Textarea,
+        Tspan,
+        Use,
+        Video,
+        Mask,
+        Symbol,
+        Marker,
+        Pattern,
+        Filter,
+        FeMerge,
+        FeMergenode,
+        FeColormatrix,
+        FeGaussianblur,
+        FeOffset,
+        FeComposite,
+        FeFlood
     };
     enum DisplayMode {
         InlineMode,
@@ -71,23 +83,33 @@ public:
         NoneMode,
         InheritMode
     };
+
 public:
     QSvgNode(QSvgNode *parent=0);
     virtual ~QSvgNode();
-    virtual void draw(QPainter *p, QSvgExtraStates &states) =0;
+    void draw(QPainter *p, QSvgExtraStates &states);
+    virtual bool separateFillStroke() const {return false;}
+    virtual void drawCommand(QPainter *p, QSvgExtraStates &states) = 0;
+    void fillThenStroke(QPainter *p, QSvgExtraStates &states);
+    QImage drawIntoBuffer(QPainter *p, QSvgExtraStates &states, const QRect &boundsRect);
+    void applyMaskToBuffer(QImage *proxy, QImage mask) const;
+    void drawWithMask(QPainter *p, QSvgExtraStates &states, const QImage &mask, const QRect &boundsRect);
+    void applyBufferToCanvas(QPainter *p, QImage proxy) const;
 
     QSvgNode *parent() const;
     bool isDescendantOf(const QSvgNode *parent) const;
 
     void appendStyleProperty(QSvgStyleProperty *prop, const QString &id);
     void applyStyle(QPainter *p, QSvgExtraStates &states) const;
+    void applyStyleRecursive(QPainter *p, QSvgExtraStates &states) const;
     void revertStyle(QPainter *p, QSvgExtraStates &states) const;
     QSvgStyleProperty *styleProperty(QSvgStyleProperty::Type type) const;
-    QSvgFillStyleProperty *styleProperty(const QString &id) const;
+    QSvgPaintStyleProperty *styleProperty(const QString &id) const;
 
     QSvgTinyDocument *document() const;
 
-    virtual Type type() const =0;
+    virtual Type type() const = 0;
+    QString typeName() const;
     virtual QRectF fastBounds(QPainter *p, QSvgExtraStates &states) const;
     virtual QRectF bounds(QPainter *p, QSvgExtraStates &states) const;
     virtual QRectF transformedBounds(QPainter *p, QSvgExtraStates &states) const;
@@ -120,11 +142,36 @@ public:
     QString xmlClass() const;
     void setXmlClass(const QString &str);
 
-    bool shouldDrawNode(QPainter *p, QSvgExtraStates &states) const;
+    QString maskId() const;
+    void setMaskId(const QString &str);
+    bool hasMask() const;
+
+    QString filterId() const;
+    void setFilterId(const QString &str);
+    bool hasFilter() const;
+
+    QString markerStartId() const;
+    void setMarkerStartId(const QString &str);
+    bool hasMarkerStart() const;
+
+    QString markerMidId() const;
+    void setMarkerMidId(const QString &str);
+    bool hasMarkerMid() const;
+
+    QString markerEndId() const;
+    void setMarkerEndId(const QString &str);
+    bool hasMarkerEnd() const;
+
+    bool hasAnyMarker() const;
+
+    virtual bool shouldDrawNode(QPainter *p, QSvgExtraStates &states) const;
+    const QSvgStyle &style() const { return m_style; }
 protected:
     mutable QSvgStyle m_style;
 
     static qreal strokeWidth(QPainter *p);
+    static void initPainter(QPainter *p);
+
 private:
     QSvgNode   *m_parent;
 
@@ -138,6 +185,12 @@ private:
 
     QString m_id;
     QString m_class;
+    QString m_maskId;
+    QString m_filterId;
+    QString m_markerStartId;
+    QString m_markerMidId;
+    QString m_markerEndId;
+
 
     DisplayMode m_displayMode;
     mutable QRectF m_cachedBounds;
diff --git a/src/svg/qsvgrenderer.cpp b/src/svg/qsvgrenderer.cpp
index 863951a..af9fa2f 100644
--- a/src/svg/qsvgrenderer.cpp
+++ b/src/svg/qsvgrenderer.cpp
@@ -73,17 +73,49 @@ public:
         : QObjectPrivate(),
           render(0), timer(0),
           fps(30)
-    {}
+    {
+        options = defaultOptions();
+    }
+
     ~QSvgRendererPrivate()
     {
         delete render;
     }
 
+    void startOrStopTimer()
+    {
+        if (animationEnabled && render && render->animated() && fps > 0) {
+            ensureTimerCreated();
+            timer->start(1000 / fps);
+        } else if (timer) {
+            timer->stop();
+        }
+    }
+
+    void ensureTimerCreated()
+    {
+        Q_Q(QSvgRenderer);
+        if (!timer) {
+            timer = new QTimer(q);
+            q->connect(timer, &QTimer::timeout, q, &QSvgRenderer::repaintNeeded);
+        }
+    }
+
     static void callRepaintNeeded(QSvgRenderer *const q);
 
+    static QtSvg::Options defaultOptions()
+    {
+        static bool envOk = false;
+        static QtSvg::Options envOpts = QtSvg::Options::fromInt(
+                qEnvironmentVariableIntValue("QT_SVG_DEFAULT_OPTIONS", &envOk));
+        return envOk ? envOpts : QtSvg::Options{};
+    }
+
     QSvgTinyDocument *render;
     QTimer *timer;
     int fps;
+    QtSvg::Options options;
+    bool animationEnabled = true;
 };
 
 /*!
@@ -196,6 +228,34 @@ bool QSvgRenderer::animated() const
         return false;
 }
 
+/*!
+    \property QSvgRenderer::animationEnabled
+    \brief whether the animation should run, if the SVG is animated
+
+    Setting the property to false stops the animation timer.
+    Setting the property to false starts the animation timer,
+    provided that the SVG contains animated elements.
+
+    If the SVG is not animated, the property will have no effect.
+    Otherwise, the property defaults to true.
+
+    \sa animated()
+
+    \since 6.7
+*/
+bool QSvgRenderer::isAnimationEnabled() const
+{
+    Q_D(const QSvgRenderer);
+    return d->animationEnabled;
+}
+
+void QSvgRenderer::setAnimationEnabled(bool enable)
+{
+    Q_D(QSvgRenderer);
+    d->animationEnabled = enable;
+    d->startOrStopTimer();
+}
+
 /*!
     \property QSvgRenderer::framesPerSecond
     \brief the number of frames per second to be shown
@@ -218,6 +278,7 @@ void QSvgRenderer::setFramesPerSecond(int num)
         return;
     }
     d->fps = num;
+    d->startOrStopTimer();
 }
 
 /*!
@@ -255,6 +316,29 @@ void QSvgRenderer::setAspectRatioMode(Qt::AspectRatioMode mode)
     }
 }
 
+/*!
+    \property QSvgRenderer::options
+    \since 6.7
+
+    This property holds a set of QtSvg::Option flags that can be used
+    to enable or disable various features of the parsing and rendering of SVG files.
+
+    Set this property before calling any of the load functions to
+    change the behavior of the QSvgRenderer.
+
+    By default, no flags are set.
+ */
+QtSvg::Options QSvgRenderer::options() const
+{
+    Q_D(const QSvgRenderer);
+    return d->options;
+}
+
+void QSvgRenderer::setOptions(QtSvg::Options flags)
+{
+    Q_D(QSvgRenderer);
+    d->options = flags;
+}
 /*!
   \property QSvgRenderer::currentFrame
   \brief the current frame of the document's animation, or 0 if the document is not animated
@@ -313,22 +397,12 @@ static bool loadDocument(QSvgRenderer *const q,
                          const TInputType &in)
 {
     delete d->render;
-    d->render = QSvgTinyDocument::load(in);
+    d->render = QSvgTinyDocument::load(in, d->options);
     if (d->render && !d->render->size().isValid()) {
         delete d->render;
         d->render = nullptr;
     }
-    if (d->render && d->render->animated() && d->fps > 0) {
-        if (!d->timer)
-            d->timer = new QTimer(q);
-        else
-            d->timer->stop();
-        q->connect(d->timer, SIGNAL(timeout()),
-                   q, SIGNAL(repaintNeeded()));
-        d->timer->start(1000/d->fps);
-    } else if (d->timer) {
-        d->timer->stop();
-    }
+    d->startOrStopTimer();
 
     //force first update
     QSvgRendererPrivate::callRepaintNeeded(q);
diff --git a/src/svg/qsvgrenderer.h b/src/svg/qsvgrenderer.h
index e5610e5..9ba8765 100644
--- a/src/svg/qsvgrenderer.h
+++ b/src/svg/qsvgrenderer.h
@@ -28,6 +28,8 @@ class Q_SVG_EXPORT QSvgRenderer : public QObject
     Q_PROPERTY(int framesPerSecond READ framesPerSecond WRITE setFramesPerSecond)
     Q_PROPERTY(int currentFrame READ currentFrame WRITE setCurrentFrame)
     Q_PROPERTY(Qt::AspectRatioMode aspectRatioMode READ aspectRatioMode WRITE setAspectRatioMode)
+    Q_PROPERTY(QtSvg::Options options READ options WRITE setOptions)
+    Q_PROPERTY(bool animationEnabled READ isAnimationEnabled WRITE setAnimationEnabled)
 public:
     QSvgRenderer(QObject *parent = nullptr);
     QSvgRenderer(const QString &filename, QObject *parent = nullptr);
@@ -47,12 +49,17 @@ public:
     Qt::AspectRatioMode aspectRatioMode() const;
     void setAspectRatioMode(Qt::AspectRatioMode mode);
 
+    QtSvg::Options options() const;
+    void setOptions(QtSvg::Options flags);
+
     bool animated() const;
     int framesPerSecond() const;
     void setFramesPerSecond(int num);
     int currentFrame() const;
     void setCurrentFrame(int);
     int animationDuration() const;//in seconds
+    bool isAnimationEnabled() const;
+    void setAnimationEnabled(bool enable);
 
     QRectF boundsOnElement(const QString &id) const;
     bool elementExists(const QString &id) const;
diff --git a/src/svg/qsvgstructure.cpp b/src/svg/qsvgstructure.cpp
index b4ac368..22f1b0d 100644
--- a/src/svg/qsvgstructure.cpp
+++ b/src/svg/qsvgstructure.cpp
@@ -2,19 +2,26 @@
 // SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
 
 #include "qsvgstructure_p.h"
+#include "qsvggraphics_p.h"
 
-#include "qsvgnode_p.h"
 #include "qsvgstyle_p.h"
 #include "qsvgtinydocument_p.h"
+#include "qsvggraphics_p.h"
+#include "qsvgstyle_p.h"
+#include "qsvgfilter_p.h"
 
 #include "qpainter.h"
 #include "qlocale.h"
 #include "qdebug.h"
 
+#include <QLoggingCategory>
 #include <qscopedvaluerollback.h>
+#include <QtGui/qimageiohandler.h>
 
 QT_BEGIN_NAMESPACE
 
+Q_DECLARE_LOGGING_CATEGORY(lcSvgDraw);
+
 QSvgG::QSvgG(QSvgNode *parent)
     : QSvgStructureNode(parent)
 {
@@ -26,23 +33,25 @@ QSvgStructureNode::~QSvgStructureNode()
     qDeleteAll(m_renderers);
 }
 
-void QSvgG::draw(QPainter *p, QSvgExtraStates &states)
+void QSvgG::drawCommand(QPainter *p, QSvgExtraStates &states)
 {
     QList<QSvgNode*>::iterator itr = m_renderers.begin();
-    applyStyle(p, states);
-
     while (itr != m_renderers.end()) {
         QSvgNode *node = *itr;
         if ((node->isVisible()) && (node->displayMode() != QSvgNode::NoneMode))
             node->draw(p, states);
         ++itr;
     }
-    revertStyle(p, states);
+}
+
+bool QSvgG::shouldDrawNode(QPainter *, QSvgExtraStates &) const
+{
+    return true;
 }
 
 QSvgNode::Type QSvgG::type() const
 {
-    return G;
+    return Group;
 }
 
 QSvgStructureNode::QSvgStructureNode(QSvgNode *parent)
@@ -74,14 +83,358 @@ QSvgDefs::QSvgDefs(QSvgNode *parent)
 {
 }
 
-void QSvgDefs::draw(QPainter *, QSvgExtraStates &)
+bool QSvgDefs::shouldDrawNode(QPainter *, QSvgExtraStates &) const
 {
-    //noop
+    return false;
 }
 
 QSvgNode::Type QSvgDefs::type() const
 {
-    return DEFS;
+    return Defs;
+}
+
+QSvgSymbolLike::QSvgSymbolLike(QSvgNode *parent, QRectF bounds, QRectF viewBox, QPointF refP,
+               QSvgSymbolLike::PreserveAspectRatios pAspectRatios, QSvgSymbolLike::Overflow overflow)
+    : QSvgStructureNode(parent)
+    , m_rect(bounds)
+    , m_viewBox(viewBox)
+    , m_refP(refP)
+    , m_pAspectRatios(pAspectRatios)
+    , m_overflow(overflow)
+{
+
+}
+
+void QSvgSymbolLike::setPainterToRectAndAdjustment(QPainter *p) const
+{
+    qreal scaleX = 1;
+    if (m_rect.width() > 0 && m_viewBox.width() > 0)
+        scaleX = m_rect.width()/m_viewBox.width();
+    qreal scaleY = 1;
+    if (m_rect.height() > 0 && m_viewBox.height() > 0)
+        scaleY = m_rect.height()/m_viewBox.height();
+
+    if (m_overflow == Overflow::Hidden) {
+        QTransform t;
+        t.translate(- m_refP.x() * scaleX - m_rect.left() - m_viewBox.left() * scaleX,
+                    - m_refP.y() * scaleY - m_rect.top() - m_viewBox.top() * scaleY);
+        t.scale(scaleX, scaleY);
+
+        if (m_viewBox.isValid())
+            p->setClipRect(t.mapRect(m_viewBox));
+    }
+
+    qreal offsetX = 0;
+    qreal offsetY = 0;
+
+    if (!qFuzzyCompare(scaleX, scaleY) &&
+        m_pAspectRatios.testAnyFlag(PreserveAspectRatio::xyMask)) {
+
+        if (m_pAspectRatios.testAnyFlag(PreserveAspectRatio::meet))
+            scaleX = scaleY = qMin(scaleX, scaleY);
+        else
+            scaleX = scaleY = qMax(scaleX, scaleY);
+
+        qreal xOverflow = scaleX * m_viewBox.width() - m_rect.width();
+        qreal yOverflow = scaleY * m_viewBox.height() - m_rect.height();
+
+        if ((m_pAspectRatios & PreserveAspectRatio::xMask) == PreserveAspectRatio::xMid)
+            offsetX -= xOverflow / 2.;
+        else if ((m_pAspectRatios & PreserveAspectRatio::xMask) == PreserveAspectRatio::xMax)
+            offsetX -= xOverflow;
+
+        if ((m_pAspectRatios & PreserveAspectRatio::yMask) == PreserveAspectRatio::yMid)
+            offsetY -= yOverflow / 2.;
+        else if ((m_pAspectRatios & PreserveAspectRatio::yMask) == PreserveAspectRatio::yMax)
+            offsetY -= yOverflow;
+    }
+
+    p->translate(offsetX - m_refP.x() * scaleX, offsetY - m_refP.y() * scaleY);
+    p->scale(scaleX, scaleY);
+}
+
+QSvgSymbol::QSvgSymbol(QSvgNode *parent, QRectF bounds, QRectF viewBox, QPointF refP,
+                       QSvgSymbol::PreserveAspectRatios pAspectRatios,
+                       QSvgSymbol::Overflow overflow)
+    : QSvgSymbolLike(parent, bounds, viewBox, refP, pAspectRatios, overflow)
+{
+}
+
+void QSvgSymbol::drawCommand(QPainter *p, QSvgExtraStates &states)
+{
+    if (!states.inUse) //Symbol is only drawn when within a use node.
+        return;
+
+    QList<QSvgNode*>::iterator itr = m_renderers.begin();
+
+    p->save();
+    setPainterToRectAndAdjustment(p);
+    while (itr != m_renderers.end()) {
+        QSvgNode *node = *itr;
+        if ((node->isVisible()) && (node->displayMode() != QSvgNode::NoneMode))
+            node->draw(p, states);
+        ++itr;
+    }
+    p->restore();
+}
+
+QSvgNode::Type QSvgSymbol::type() const
+{
+    return Symbol;
+}
+
+QSvgMarker::QSvgMarker(QSvgNode *parent, QRectF bounds, QRectF viewBox, QPointF refP,
+                       QSvgSymbol::PreserveAspectRatios pAspectRatios, QSvgSymbol::Overflow overflow,
+                       Orientation orientation, qreal orientationAngle, MarkerUnits markerUnits)
+    : QSvgSymbolLike(parent, bounds, viewBox, refP, pAspectRatios, overflow)
+    , m_orientation(orientation)
+    , m_orientationAngle(orientationAngle)
+    , m_markerUnits(markerUnits)
+{
+    // apply the svg standard style
+    QSvgFillStyle *fillProp = new QSvgFillStyle();
+    fillProp->setBrush(Qt::black);
+    appendStyleProperty(fillProp, QStringLiteral(""));
+
+    QSvgStrokeStyle *strokeProp = new QSvgStrokeStyle();
+    strokeProp->setMiterLimit(4);
+    strokeProp->setWidth(1);
+    strokeProp->setLineCap(Qt::FlatCap);
+    strokeProp->setLineJoin(Qt::SvgMiterJoin);
+    strokeProp->setStroke(Qt::NoBrush);
+    appendStyleProperty(strokeProp, QStringLiteral(""));
+}
+
+QSvgFilterContainer::QSvgFilterContainer(QSvgNode *parent, const QSvgRectF &bounds,
+                                         QtSvg::UnitTypes filterUnits, QtSvg::UnitTypes primitiveUnits)
+    : QSvgStructureNode(parent)
+    , m_rect(bounds)
+    , m_filterUnits(filterUnits)
+    , m_primitiveUnits(primitiveUnits)
+{
+
+}
+
+void QSvgMarker::drawCommand(QPainter *p, QSvgExtraStates &states)
+{
+    if (!states.inUse) //Symbol is only drawn in combination with another node.
+        return;
+
+    if (Q_UNLIKELY(m_recursing))
+        return;
+    QScopedValueRollback<bool> recursingGuard(m_recursing, true);
+
+    QList<QSvgNode*>::iterator itr = m_renderers.begin();
+
+    p->save();
+    applyStyle(p, states);
+
+    setPainterToRectAndAdjustment(p);
+
+    while (itr != m_renderers.end()) {
+        QSvgNode *node = *itr;
+        if ((node->isVisible()) && (node->displayMode() != QSvgNode::NoneMode))
+            node->draw(p, states);
+        ++itr;
+    }
+    revertStyle(p, states);
+    p->restore();
+}
+
+void QSvgMarker::drawMarkersForNode(QSvgNode *node, QPainter *p, QSvgExtraStates &states)
+{
+    QScopedValueRollback<bool> inUseGuard(states.inUse, true);
+
+    auto getMeanAngle = [] (QPointF p0, QPointF p1, QPointF p2) {
+        QPointF t1 = p1 - p0;
+        QPointF t2 = p2 - p1;
+        qreal hyp1 =  hypot(t1.x(), t1.y());
+        if (hyp1 > 0)
+            t1 /= hyp1;
+        else
+            return 0.;
+        qreal hyp2 =  hypot(t2.x(), t2.y());
+        if (hyp2 > 0)
+            t2 /= hyp2;
+        else
+            return 0.;
+        QPointF tangent = t1 + t2;
+        return -atan2(tangent.y(), tangent.x()) / M_PI * 180.;
+    };
+
+    if (node->hasAnyMarker()) {
+        QList<PositionMarkerPair> marks;
+        if (node->type() == Line) {
+            QSvgLine *line = static_cast<QSvgLine*>(node);
+            if (!line)
+                return;
+            if (node->hasMarkerStart())
+                marks << PositionMarkerPair { line->line().p1().x(), line->line().p1().y(),
+                                              line->line().angle(), line->markerStartId(),
+                                              true};
+            if (node->hasMarkerEnd())
+                marks << PositionMarkerPair { line->line().p2().x(), line->line().p2().y(),
+                                              line->line().angle(), line->markerEndId() };
+        } else if (node->type() == Polyline || node->type() == Polygon) {
+            QSvgPolyline *polyline = static_cast<QSvgPolyline*>(node);
+            QSvgPolygon *polygon = static_cast<QSvgPolygon*>(node);
+
+            const QPolygonF &polyData = (node->type() == Polyline) ? polyline->polygon() : polygon->polygon();
+
+            if (node->hasMarkerStart() && polyData.size() > 1) {
+                QLineF line(polyData.at(0), polyData.at(1));
+                marks << PositionMarkerPair { line.p1().x(),
+                                              line.p1().y(),
+                                              line.angle(),
+                                              node->markerStartId(),
+                                              true };
+            }
+            if (node->hasMarkerMid()) {
+                for (int i = 1; i < polyData.size() - 1; i++) {
+                    QPointF p0 = polyData.at(i-1);
+                    QPointF p1 = polyData.at(i);
+                    QPointF p2 = polyData.at(i+1);
+
+                    marks << PositionMarkerPair { p1.x(),
+                                                  p1.y(),
+                                                  getMeanAngle(p0, p1, p2),
+                                                  node->markerStartId() };
+                }
+            }
+            if (node->hasMarkerEnd() && polyData.size() > 1) {
+                QLineF line(polyData.at(polyData.size()-1), polyData.last());
+                marks << PositionMarkerPair { line.p2().x(),
+                                              line.p2().y(),
+                                              line.angle(),
+                                              node->markerEndId() };
+            }
+        } else if (node->type() == Path) {
+            QSvgPath *path = static_cast<QSvgPath*>(node);
+            if (!path)
+                return;
+            if (node->hasMarkerStart())
+                marks << PositionMarkerPair { path->path().pointAtPercent(0.).x(),
+                                              path->path().pointAtPercent(0.).y(),
+                                              path->path().angleAtPercent(0.),
+                                              path->markerStartId(),
+                                              true };
+            if (node->hasMarkerMid()) {
+                for (int i = 1; i < path->path().elementCount() - 1; i++) {
+                    if (path->path().elementAt(i).type == QPainterPath::MoveToElement)
+                        continue;
+                    if (path->path().elementAt(i).type == QPainterPath::CurveToElement)
+                        continue;
+                    if (( path->path().elementAt(i).type == QPainterPath::CurveToDataElement &&
+                        path->path().elementAt(i+1).type != QPainterPath::CurveToDataElement ) ||
+                        path->path().elementAt(i).type == QPainterPath::LineToElement) {
+
+                        QPointF p0(path->path().elementAt(i-1).x, path->path().elementAt(i-1).y);
+                        QPointF p1(path->path().elementAt(i).x, path->path().elementAt(i).y);
+                        QPointF p2(path->path().elementAt(i+1).x, path->path().elementAt(i+1).y);
+
+                        marks << PositionMarkerPair { p1.x(),
+                                                      p1.y(),
+                                                      getMeanAngle(p0, p1, p2),
+                                                      path->markerMidId() };
+                    }
+                }
+            }
+            if (node->hasMarkerEnd())
+                marks << PositionMarkerPair { path->path().pointAtPercent(1.).x(),
+                                              path->path().pointAtPercent(1.).y(),
+                                              path->path().angleAtPercent(1.),
+                                              path->markerEndId() };
+        }
+        for (auto &i : marks) {
+            QSvgMarker *markNode = static_cast<QSvgMarker*>(node->document()->namedNode(i.markerId));
+            if (!markNode) {
+                continue;
+            }
+            p->save();
+            p->translate(i.x, i.y);
+            if (markNode->orientation() == QSvgMarker::Orientation::Value)
+                p->rotate(markNode->orientationAngle());
+            else {
+                p->rotate(-i.angle);
+                if (i.isStartNode && markNode->orientation() == QSvgMarker::Orientation::AutoStartReverse)
+                    p->rotate(-180);
+            }
+            QRectF oldRect = markNode->m_rect;
+            if (markNode->markerUnits() == QSvgMarker::MarkerUnits::StrokeWidth) {
+                markNode->m_rect.setWidth(markNode->m_rect.width() * p->pen().widthF());
+                markNode->m_rect.setHeight(markNode->m_rect.height() * p->pen().widthF());
+            }
+            markNode->draw(p, states);
+            markNode->m_rect = oldRect;
+            p->restore();
+        }
+    }
+}
+
+QSvgNode::Type QSvgMarker::type() const
+{
+    return Marker;
+}
+
+QImage QSvgFilterContainer::applyFilter(QSvgNode *item, const QImage &buffer, QPainter *p, QRectF bounds) const
+{
+    QRectF filterBounds = m_rect.combinedWithLocalRect(bounds, document()->viewBox(), m_filterUnits);
+    QRect filterBoundsGlob = p->transform().mapRect(filterBounds).toRect();
+    QRect filterBoundsGlobRel = filterBoundsGlob.translated(-buffer.offset());
+
+    if (filterBoundsGlobRel.isEmpty())
+        return buffer;
+
+    QImage proxy;
+    if (!QImageIOHandler::allocateImage(filterBoundsGlobRel.size(), buffer.format(), &proxy)) {
+        qCWarning(lcSvgDraw) << "The requested filter is too big, ignoring";
+        return buffer;
+    }
+    proxy = buffer.copy(filterBoundsGlobRel);
+    proxy.setOffset(filterBoundsGlob.topLeft());
+    if (proxy.isNull())
+        return buffer;
+
+    QMap<QString, QImage> buffers;
+    buffers[QStringLiteral("")] = proxy;
+    buffers[QStringLiteral("SourceGraphic")] = proxy;
+
+    bool requiresSourceAlpha = false;
+
+    const QList<QSvgNode *> children = renderers();
+    for (const QSvgNode *renderer : children) {
+        const QSvgFeFilterPrimitive *filter = QSvgFeFilterPrimitive::castToFilterPrimitive(renderer);
+        if (filter && filter->requiresSourceAlpha()) {
+            requiresSourceAlpha = true;
+            break;
+        }
+    }
+
+    if (requiresSourceAlpha) {
+        QImage proxyAlpha = proxy.convertedTo(QImage::Format_Alpha8).convertedTo(proxy.format());
+        proxyAlpha.setOffset(proxy.offset());
+        if (proxyAlpha.isNull())
+            return buffer;
+        buffers[QStringLiteral("SourceAlpha")] = proxyAlpha;
+    }
+
+    QImage result;
+    for (const QSvgNode *renderer : children) {
+        const QSvgFeFilterPrimitive *filter = QSvgFeFilterPrimitive::castToFilterPrimitive(renderer);
+        if (filter) {
+            result = filter->apply(item, buffers, p, bounds, filterBounds, m_primitiveUnits, m_filterUnits);
+            if (!result.isNull()) {
+                buffers[QStringLiteral("")] = result;
+                buffers[filter->result()] = result;
+            }
+        }
+    }
+    return result;
+}
+
+QSvgNode::Type QSvgFilterContainer::type() const
+{
+    return Filter;
 }
 
 /*
@@ -246,10 +599,9 @@ QSvgSwitch::QSvgSwitch(QSvgNode *parent)
     init();
 }
 
-void QSvgSwitch::draw(QPainter *p, QSvgExtraStates &states)
+void QSvgSwitch::drawCommand(QPainter *p, QSvgExtraStates &states)
 {
     QList<QSvgNode*>::iterator itr = m_renderers.begin();
-    applyStyle(p, states);
 
     while (itr != m_renderers.end()) {
         QSvgNode *node = *itr;
@@ -307,12 +659,11 @@ void QSvgSwitch::draw(QPainter *p, QSvgExtraStates &states)
         }
         ++itr;
     }
-    revertStyle(p, states);
 }
 
 QSvgNode::Type QSvgSwitch::type() const
 {
-    return SWITCH;
+    return Switch;
 }
 
 void QSvgSwitch::init()
@@ -334,7 +685,7 @@ QRectF QSvgStructureNode::bounds(QPainter *p, QSvgExtraStates &states) const
     return bounds;
 }
 
-QSvgNode * QSvgStructureNode::previousSiblingNode(QSvgNode *n) const
+QSvgNode* QSvgStructureNode::previousSiblingNode(QSvgNode *n) const
 {
     QSvgNode *prev = nullptr;
     QList<QSvgNode*>::const_iterator itr = m_renderers.constBegin();
@@ -347,4 +698,252 @@ QSvgNode * QSvgStructureNode::previousSiblingNode(QSvgNode *n) const
     return prev;
 }
 
+QSvgMask::QSvgMask(QSvgNode *parent, QSvgRectF bounds,
+                   QtSvg::UnitTypes contentUnits)
+    : QSvgStructureNode(parent)
+    , m_rect(bounds)
+    , m_contentUnits(contentUnits)
+{
+}
+
+QImage QSvgMask::createMask(QPainter *p, QSvgExtraStates &states, QSvgNode *targetNode, QRectF *globalRect) const
+{
+    QTransform t = p->transform();
+    p->resetTransform();
+    QRectF basicRect = targetNode->bounds(p, states);
+    *globalRect = t.mapRect(basicRect);
+    p->setTransform(t);
+    return createMask(p, states, basicRect, globalRect);
+}
+
+QImage QSvgMask::createMask(QPainter *p, QSvgExtraStates &states, const QRectF &localRect, QRectF *globalRect) const
+{
+    QRect imageBound = globalRect->toAlignedRect();
+    *globalRect = imageBound.toRectF();
+
+    QImage mask;
+    if (!QImageIOHandler::allocateImage(imageBound.size(), QImage::Format_RGBA8888, &mask)) {
+        qCWarning(lcSvgDraw) << "The requested mask size is too big, ignoring";
+        return mask;
+    }
+
+    if (Q_UNLIKELY(m_recursing))
+        return mask;
+    QScopedValueRollback<bool> recursingGuard(m_recursing, true);
+
+    // Chrome seems to return the mask of the mask if a mask is set on the mask
+    if (this->hasMask()) {
+        QSvgMask *maskNode = static_cast<QSvgMask*>(document()->namedNode(this->maskId()));
+        if (maskNode) {
+            QRectF boundsRect;
+            return maskNode->createMask(p, states, localRect, &boundsRect);
+        }
+    }
+
+    // The mask is created with other elements during rendering.
+    // Black pixels are masked out, white pixels are not masked.
+    // The strategy is to draw the elements in a buffer (QImage) and to map
+    // the white-black image into a transparent-white image that can be used
+    // with QPainters composition mode to set the mask.
+
+    mask.fill(Qt::transparent);
+    QPainter painter(&mask);
+    initPainter(&painter);
+
+    QSvgExtraStates maskNodeStates;
+    applyStyleRecursive(&painter, maskNodeStates);
+
+    // The transformation of the mask node is not relevant. What matters are the contentUnits
+    // and the position/scale of the node that the mask is applied to.
+    painter.resetTransform();
+    painter.translate(-imageBound.topLeft());
+    painter.setTransform(p->transform(), true);
+
+    QTransform oldT = painter.transform();
+    if (m_contentUnits == QtSvg::UnitTypes::objectBoundingBox){
+        painter.translate(localRect.topLeft());
+        painter.scale(localRect.width(), localRect.height());
+    }
+
+    // Draw all content items of the mask to generate the mask
+    QList<QSvgNode*>::const_iterator itr = m_renderers.begin();
+    while (itr != m_renderers.end()) {
+        QSvgNode *node = *itr;
+        if ((node->isVisible()) && (node->displayMode() != QSvgNode::NoneMode))
+            node->draw(&painter, maskNodeStates);
+        ++itr;
+    }
+
+    for (int i=0; i < mask.height(); i++) {
+        QRgb *line = reinterpret_cast<QRgb *>(mask.scanLine(i));
+        for (int j=0; j < mask.width(); j++) {
+            const qreal rC = 0.2125, gC = 0.7154, bC = 0.0721; //luminanceToAlpha times alpha following SVG 1.1
+            int alpha = 255 - (qRed(line[j]) * rC + qGreen(line[j]) * gC + qBlue(line[j]) * bC) * qAlpha(line[j])/255.;
+            line[j] = qRgba(0, 0, 0, alpha);
+        }
+    }
+
+    // Make a path out of the clipRectangle and draw it inverted - black over all content items.
+    // This is required to apply a clip rectangle with transformations.
+    // painter.setClipRect(clipRect) sounds like the obvious thing to do but
+    // created artifacts due to antialiasing.
+    QRectF clipRect = m_rect.combinedWithLocalRect(localRect);
+    QPainterPath clipPath;
+    clipPath.setFillRule(Qt::OddEvenFill);
+    clipPath.addRect(mask.rect().adjusted(-10, -10, 20, 20));
+    clipPath.addPolygon(oldT.map(QPolygonF(clipRect)));
+    painter.resetTransform();
+    painter.fillPath(clipPath, Qt::black);
+
+    return mask;
+}
+
+QSvgNode::Type QSvgMask::type() const
+{
+    return Mask;
+}
+
+QSvgPattern::QSvgPattern(QSvgNode *parent, QSvgRectF bounds, QRectF viewBox,
+                         QtSvg::UnitTypes contentUnits, QTransform transform)
+    : QSvgStructureNode(parent),
+    m_rect(bounds),
+    m_viewBox(viewBox),
+    m_contentUnits(contentUnits),
+    m_transform(transform)
+
+{
+
+}
+
+static QImage& defaultPattern()
+{
+    static QImage checkerPattern;
+
+    if (checkerPattern.isNull()) {
+        checkerPattern = QImage(QSize(8, 8), QImage::Format_ARGB32);
+        QPainter p(&checkerPattern);
+        p.fillRect(QRect(0, 0, 4, 4), QColorConstants::Svg::white);
+        p.fillRect(QRect(4, 0, 4, 4), QColorConstants::Svg::black);
+        p.fillRect(QRect(0, 4, 4, 4), QColorConstants::Svg::black);
+        p.fillRect(QRect(4, 4, 4, 4), QColorConstants::Svg::white);
+    }
+
+    return checkerPattern;
+}
+
+QImage QSvgPattern::patternImage(QPainter *p, QSvgExtraStates &states, const QSvgNode *patternElement)
+{
+    // pe stands for Pattern Element
+    QRectF peBoundingBox;
+    QRectF peWorldBoundingBox;
+
+    QTransform t = p->transform();
+    p->resetTransform();
+    peBoundingBox = patternElement->bounds(p, states);
+    peWorldBoundingBox = t.mapRect(peBoundingBox);
+    p->setTransform(t);
+
+    // This function renders the pattern into an Image, so we need to apply the correct
+    // scaling values when we draw the pattern. The scaling is affected by two factors :
+    //      - The "patternTransform" attribute which itself might contain a scaling
+    //      - The scaling applied globally.
+    // The first is obtained from m11 and m22 matrix elements,
+    // while the second is calculated by dividing the patternElement global size
+    // by its local size.
+    qreal contentScaleFactorX = m_transform.m11();
+    qreal contentScaleFactorY = m_transform.m22();
+    if (m_contentUnits == QtSvg::UnitTypes::userSpaceOnUse) {
+        contentScaleFactorX *= t.m11();
+        contentScaleFactorY *= t.m22();
+    } else {
+        contentScaleFactorX *= peWorldBoundingBox.width();
+        contentScaleFactorY *= peWorldBoundingBox.height();
+    }
+
+    // Calculate the pattern bounding box depending on the used UnitTypes
+    QRectF patternBoundingBox = m_rect.combinedWithLocalRect(peBoundingBox);
+
+    QSize imageSize;
+    imageSize.setWidth(qCeil(patternBoundingBox.width() * t.m11() * m_transform.m11()));
+    imageSize.setHeight(qCeil(patternBoundingBox.height() * t.m22() * m_transform.m22()));
+
+    calculateAppliedTransform(t, peBoundingBox, imageSize);
+    return renderPattern(imageSize, contentScaleFactorX, contentScaleFactorY);
+}
+
+QSvgNode::Type QSvgPattern::type() const
+{
+    return Pattern;
+}
+
+QImage QSvgPattern::renderPattern(QSize size, qreal contentScaleX, qreal contentScaleY)
+{
+    if (size.isEmpty() || !qIsFinite(contentScaleX) || !qIsFinite(contentScaleY))
+        return defaultPattern();
+
+    // Allocate a QImage to draw the pattern in with the calculated size.
+    QImage pattern;
+    if (!QImageIOHandler::allocateImage(size, QImage::Format_ARGB32, &pattern)) {
+        qCWarning(lcSvgDraw) << "The requested pattern size is too big, ignoring";
+        return defaultPattern();
+    }
+    pattern.fill(Qt::transparent);
+
+    // Draw the pattern using our QPainter.
+    QPainter patternPainter(&pattern);
+    QSvgExtraStates patternStates;
+    initPainter(&patternPainter);
+    applyStyleRecursive(&patternPainter, patternStates);
+    patternPainter.resetTransform();
+
+    // According to the <pattern> definition, if viewBox exists then patternContentUnits
+    // is ignored
+    if (m_viewBox.isNull())
+        patternPainter.scale(contentScaleX, contentScaleY);
+    else
+        patternPainter.setWindow(m_viewBox.toRect());
+
+    // Draw all this Pattern children nodes with our QPainter,
+    // no need to use any Extra States
+    for (QSvgNode *node : m_renderers)
+        node->draw(&patternPainter, patternStates);
+
+    return pattern;
+}
+
+void QSvgPattern::calculateAppliedTransform(QTransform &worldTransform, QRectF peLocalBB, QSize imageSize)
+{
+    // Calculate the required transform to be applied to the QBrush used for correct
+    // pattern drawing with the object being rendered.
+    // Scale : Apply inverse the scale used above because QBrush uses the transform used
+    //         by the QPainter and this function has already rendered the QImage with the
+    //         correct size. Moreover, take into account the difference between the required
+    //         ideal image size in float and the QSize given to image as an integer value.
+    //
+    // Translate : Apply translation depending on the calculated x and y values so that the
+    //             drawn pattern can be shifted inside the object.
+    // Pattern Transform : Apply the transform in the "patternTransform" attribute. This
+    //                     transform contains everything except scaling, because it is
+    //                     already applied above on the QImage and the QPainter while
+    //                     drawing the pattern tile.
+    m_appliedTransform.reset();
+    qreal imageDownScaleFactorX = 1 / worldTransform.m11();
+    qreal imageDownScaleFactorY = 1 / worldTransform.m22();
+
+    m_appliedTransform.scale(qIsFinite(imageDownScaleFactorX) ? imageDownScaleFactorX : 1.0,
+                             qIsFinite(imageDownScaleFactorY) ? imageDownScaleFactorY : 1.0);
+
+    QRectF p = m_rect.combinedWithLocalRect(peLocalBB);
+    m_appliedTransform.scale((p.width() * worldTransform.m11() * m_transform.m11()) / imageSize.width(),
+                             (p.height() * worldTransform.m22() * m_transform.m22()) / imageSize.height());
+
+    QPointF translation = m_rect.translationRelativeToBoundingBox(peLocalBB);
+    m_appliedTransform.translate(translation.x() * worldTransform.m11(), translation.y() * worldTransform.m22());
+
+    QTransform scalelessTransform = m_transform;
+    scalelessTransform.scale(1 / m_transform.m11(), 1 / m_transform.m22());
+
+    m_appliedTransform = m_appliedTransform * scalelessTransform;
+}
+
 QT_END_NAMESPACE
diff --git a/src/svg/qsvgstructure_p.h b/src/svg/qsvgstructure_p.h
index f2c0c0f..9a3c2a0 100644
--- a/src/svg/qsvgstructure_p.h
+++ b/src/svg/qsvgstructure_p.h
@@ -16,7 +16,6 @@
 //
 
 #include "qsvgnode_p.h"
-#include "qtsvgglobal_p.h"
 
 #include "QtCore/qlist.h"
 #include "QtCore/qhash.h"
@@ -28,7 +27,7 @@ class QSvgNode;
 class QPainter;
 class QSvgDefs;
 
-class Q_SVG_PRIVATE_EXPORT QSvgStructureNode : public QSvgNode
+class Q_SVG_EXPORT QSvgStructureNode : public QSvgNode
 {
 public:
     QSvgStructureNode(QSvgNode *parent);
@@ -45,27 +44,139 @@ protected:
     mutable bool              m_recursing = false;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgG : public QSvgStructureNode
+class Q_SVG_EXPORT QSvgG : public QSvgStructureNode
 {
 public:
     QSvgG(QSvgNode *parent);
-    void draw(QPainter *p, QSvgExtraStates &states) override;
+    void drawCommand(QPainter *, QSvgExtraStates &) override;
+    bool shouldDrawNode(QPainter *p, QSvgExtraStates &states) const override;
     Type type() const override;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgDefs : public QSvgStructureNode
+class Q_SVG_EXPORT QSvgDefs : public QSvgStructureNode
 {
 public:
     QSvgDefs(QSvgNode *parent);
-    void draw(QPainter *p, QSvgExtraStates &states) override;
+    void drawCommand(QPainter *, QSvgExtraStates &) override {};
+    bool shouldDrawNode(QPainter *p, QSvgExtraStates &states) const override;
     Type type() const override;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgSwitch : public QSvgStructureNode
+class Q_SVG_EXPORT QSvgSymbolLike : public QSvgStructureNode
+{
+    // Marker, Symbol and potentially other elements share a lot of common
+    // attributes and functionality. By making a common base class we can
+    // avoid repetition.
+public:
+    enum class Overflow : quint8 {
+        Visible,
+        Hidden,
+        Scroll = Visible, //Will not support scrolling
+        Auto = Visible
+    };
+
+    enum class PreserveAspectRatio : quint8 {
+        None =  0b000000,
+        xMin =  0b000001,
+        xMid =  0b000010,
+        xMax =  0b000011,
+        yMin =  0b000100,
+        yMid =  0b001000,
+        yMax =  0b001100,
+        meet =  0b010000,
+        slice = 0b100000,
+        xMask = xMin | xMid | xMax,
+        yMask = yMin | yMid | yMax,
+        xyMask = xMask | yMask,
+        meetSliceMask = meet | slice
+    };
+    Q_DECLARE_FLAGS(PreserveAspectRatios, PreserveAspectRatio)
+
+    QSvgSymbolLike(QSvgNode *parent, QRectF bounds, QRectF viewBox, QPointF refP,
+                   QSvgSymbolLike::PreserveAspectRatios pAspectRatios, QSvgSymbolLike::Overflow overflow);
+    void drawCommand(QPainter *, QSvgExtraStates &) override {};
+protected:
+    void setPainterToRectAndAdjustment(QPainter *p) const;
+protected:
+    QRectF m_rect;
+    QRectF m_viewBox;
+    QPointF m_refP;
+    PreserveAspectRatios m_pAspectRatios;
+    Overflow m_overflow;
+};
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(QSvgSymbolLike::PreserveAspectRatios)
+
+class Q_SVG_EXPORT QSvgSymbol : public QSvgSymbolLike
+{
+public:
+    QSvgSymbol(QSvgNode *parent, QRectF bounds, QRectF viewBox, QPointF refP,
+               QSvgSymbolLike::PreserveAspectRatios pAspectRatios, QSvgSymbolLike::Overflow overflow);
+    void drawCommand(QPainter *p, QSvgExtraStates &states) override;
+    Type type() const override;
+};
+
+class Q_SVG_EXPORT QSvgMarker : public QSvgSymbolLike
+{
+public:
+    enum class Orientation : quint8 {
+        Auto,
+        AutoStartReverse,
+        Value
+    };
+    enum class MarkerUnits : quint8 {
+        StrokeWidth,
+        UserSpaceOnUse
+    };
+
+    QSvgMarker(QSvgNode *parent, QRectF bounds, QRectF viewBox, QPointF refP,
+               QSvgSymbolLike::PreserveAspectRatios pAspectRatios, QSvgSymbolLike::Overflow overflow,
+               Orientation orientation, qreal orientationAngle, MarkerUnits markerUnits);
+    void drawCommand(QPainter *p, QSvgExtraStates &states) override;
+    static void drawMarkersForNode(QSvgNode *node, QPainter *p, QSvgExtraStates &states);
+    Orientation orientation() const {
+        return m_orientation;
+    }
+    qreal orientationAngle() const {
+        return m_orientationAngle;
+    }
+    MarkerUnits markerUnits() const {
+        return m_markerUnits;
+    }
+    Type type() const override;
+private:
+    struct PositionMarkerPair {
+        qreal x;
+        qreal y;
+        qreal angle;
+        QString markerId;
+        bool isStartNode = false;
+    };
+    Orientation m_orientation;
+    qreal m_orientationAngle;
+    MarkerUnits m_markerUnits;
+};
+
+class Q_SVG_EXPORT QSvgFilterContainer : public QSvgStructureNode
+{
+public:
+
+    QSvgFilterContainer(QSvgNode *parent, const QSvgRectF &bounds, QtSvg::UnitTypes filterUnits, QtSvg::UnitTypes primitiveUnits);
+    void drawCommand(QPainter *, QSvgExtraStates &) override {};
+    Type type() const override;
+    QImage applyFilter(QSvgNode *referenceNode, const QImage &buffer, QPainter *p, QRectF bounds) const;
+private:
+    QSvgRectF m_rect;
+    QtSvg::UnitTypes m_filterUnits;
+    QtSvg::UnitTypes m_primitiveUnits;
+};
+
+
+class Q_SVG_EXPORT QSvgSwitch : public QSvgStructureNode
 {
 public:
     QSvgSwitch(QSvgNode *parent);
-    void draw(QPainter *p, QSvgExtraStates &states) override;
+    void drawCommand(QPainter *p, QSvgExtraStates &states) override;
     Type type() const override;
 private:
     void init();
@@ -74,6 +185,53 @@ private:
     QString m_systemLanguagePrefix;
 };
 
+class Q_SVG_EXPORT QSvgMask : public QSvgStructureNode
+{
+public:
+    QSvgMask(QSvgNode *parent, QSvgRectF bounds,
+             QtSvg::UnitTypes contentsUnits);
+    void drawCommand(QPainter *, QSvgExtraStates &) override {};
+    Type type() const override;
+    QImage createMask(QPainter *p, QSvgExtraStates &states, QSvgNode *targetNode, QRectF *globalRect) const;
+    QImage createMask(QPainter *p, QSvgExtraStates &states, const QRectF &localRect, QRectF *globalRect) const;
+
+    QSvgRectF rect() const
+    {
+        return m_rect;
+    }
+
+    QtSvg::UnitTypes contentUnits() const
+    {
+        return m_contentUnits;
+    }
+
+private:
+    QSvgRectF m_rect;
+    QtSvg::UnitTypes m_contentUnits;
+};
+
+class Q_SVG_EXPORT QSvgPattern : public QSvgStructureNode
+{
+public:
+    QSvgPattern(QSvgNode *parent, QSvgRectF bounds, QRectF viewBox,
+                QtSvg::UnitTypes contentUnits, QTransform transform);
+    void drawCommand(QPainter *, QSvgExtraStates &) override {};
+    QImage patternImage(QPainter *p, QSvgExtraStates &states, const QSvgNode *patternElement);
+    Type type() const override;
+    const QTransform& appliedTransform() const { return m_appliedTransform; }
+
+private:
+    QImage renderPattern(QSize size, qreal contentScaleX, qreal contentScaleY);
+    void calculateAppliedTransform(QTransform& worldTransform, QRectF peLocalBB, QSize imageSize);
+
+private:
+    QTransform m_appliedTransform;
+    QSvgRectF m_rect;
+    QRectF m_viewBox;
+    QtSvg::UnitTypes m_contentUnits;
+    QTransform m_transform;
+};
+
 QT_END_NAMESPACE
 
 #endif // QSVGSTRUCTURE_P_H
diff --git a/src/svg/qsvgstyle.cpp b/src/svg/qsvgstyle.cpp
index 604b4e4..953d59f 100644
--- a/src/svg/qsvgstyle.cpp
+++ b/src/svg/qsvgstyle.cpp
@@ -34,12 +34,12 @@ QSvgStyleProperty::~QSvgStyleProperty()
 {
 }
 
-void QSvgFillStyleProperty::apply(QPainter *, const QSvgNode *, QSvgExtraStates &)
+void QSvgPaintStyleProperty::apply(QPainter *, const QSvgNode *, QSvgExtraStates &)
 {
     Q_ASSERT(!"This should not be called!");
 }
 
-void QSvgFillStyleProperty::revert(QPainter *, QSvgExtraStates &)
+void QSvgPaintStyleProperty::revert(QPainter *, QSvgExtraStates &)
 {
     Q_ASSERT(!"This should not be called!");
 }
@@ -94,7 +94,7 @@ QSvgFillStyle::QSvgFillStyle()
     , m_oldFillRule(Qt::WindingFill)
     , m_fillOpacity(1.0)
     , m_oldFillOpacity(0)
-    , m_gradientResolved(1)
+    , m_paintStyleResolved(1)
     , m_fillRuleSet(0)
     , m_fillOpacitySet(0)
     , m_fillSet(0)
@@ -113,7 +113,7 @@ void QSvgFillStyle::setFillOpacity(qreal opacity)
     m_fillOpacity = opacity;
 }
 
-void QSvgFillStyle::setFillStyle(QSvgFillStyleProperty* style)
+void QSvgFillStyle::setFillStyle(QSvgPaintStyleProperty* style)
 {
     m_style = style;
     m_fillSet = 1;
@@ -126,7 +126,7 @@ void QSvgFillStyle::setBrush(QBrush brush)
     m_fillSet = 1;
 }
 
-void QSvgFillStyle::apply(QPainter *p, const QSvgNode *, QSvgExtraStates &states)
+void QSvgFillStyle::apply(QPainter *p, const QSvgNode *n, QSvgExtraStates &states)
 {
     m_oldFill = p->brush();
     m_oldFillRule = states.fillRule;
@@ -136,7 +136,7 @@ void QSvgFillStyle::apply(QPainter *p, const QSvgNode *, QSvgExtraStates &states
         states.fillRule = m_fillRule;
     if (m_fillSet) {
         if (m_style)
-            p->setBrush(m_style->brush(p, states));
+            p->setBrush(m_style->brush(p, n, states));
         else
             p->setBrush(m_fill);
     }
@@ -249,7 +249,7 @@ QSvgStrokeStyle::QSvgStrokeStyle()
     , m_strokeDashOffset(0)
     , m_oldStrokeDashOffset(0)
     , m_style(0)
-    , m_gradientResolved(1)
+    , m_paintStyleResolved(1)
     , m_vectorEffect(0)
     , m_oldVectorEffect(0)
     , m_strokeSet(0)
@@ -264,7 +264,7 @@ QSvgStrokeStyle::QSvgStrokeStyle()
 {
 }
 
-void QSvgStrokeStyle::apply(QPainter *p, const QSvgNode *, QSvgExtraStates &states)
+void QSvgStrokeStyle::apply(QPainter *p, const QSvgNode *n, QSvgExtraStates &states)
 {
     m_oldStroke = p->pen();
     m_oldStrokeOpacity = states.strokeOpacity;
@@ -289,7 +289,7 @@ void QSvgStrokeStyle::apply(QPainter *p, const QSvgNode *, QSvgExtraStates &stat
 
     if (m_strokeSet) {
         if (m_style)
-            pen.setBrush(m_style->brush(p, states));
+            pen.setBrush(m_style->brush(p, n, states));
         else
             pen.setBrush(m_stroke.brush());
     }
@@ -384,7 +384,7 @@ QSvgGradientStyle::QSvgGradientStyle(QGradient *grad)
 {
 }
 
-QBrush QSvgGradientStyle::brush(QPainter *, QSvgExtraStates &)
+QBrush QSvgGradientStyle::brush(QPainter *, const QSvgNode *, QSvgExtraStates &)
 {
     if (!m_link.isEmpty()) {
         resolveStops();
@@ -410,6 +410,20 @@ void QSvgGradientStyle::setTransform(const QTransform &transform)
     m_transform = transform;
 }
 
+QSvgPatternStyle::QSvgPatternStyle(QSvgPattern *pattern)
+    : m_pattern(pattern)
+{
+
+}
+
+QBrush QSvgPatternStyle::brush(QPainter *p, const QSvgNode *node, QSvgExtraStates &states)
+{
+    m_patternImage = m_pattern->patternImage(p, states, node);
+    QBrush b(m_patternImage);
+    b.setTransform(m_pattern->appliedTransform());
+    return b;
+}
+
 QSvgTransformStyle::QSvgTransformStyle(const QTransform &trans)
     : m_transform(trans)
 {
@@ -461,6 +475,11 @@ QSvgStyleProperty::Type QSvgGradientStyle::type() const
     return GRADIENT;
 }
 
+QSvgStyleProperty::Type QSvgPatternStyle::type() const
+{
+    return PATTERN;
+}
+
 QSvgStyleProperty::Type QSvgTransformStyle::type() const
 {
     return TRANSFORM;
@@ -654,25 +673,24 @@ void QSvgAnimateTransform::resolveMatrix(const QSvgNode *node)
     if (totalTimeElapsed < m_from || m_finished)
         return;
 
-    qreal animationFrame = 0;
+    qreal fractionOfTotalTime = 0;
     if (m_totalRunningTime != 0) {
-        animationFrame = (totalTimeElapsed - m_from) / m_totalRunningTime;
+        fractionOfTotalTime = (totalTimeElapsed - m_from) / m_totalRunningTime;
 
-        if (m_repeatCount >= 0 && m_repeatCount < animationFrame) {
+        if (m_repeatCount >= 0 && m_repeatCount < fractionOfTotalTime) {
             m_finished = true;
-            animationFrame = m_repeatCount;
+            fractionOfTotalTime = m_repeatCount;
         }
     }
 
-    qreal percentOfAnimation = animationFrame;
-    if (percentOfAnimation > 1) {
-        percentOfAnimation -= ((int)percentOfAnimation);
-    }
+    qreal fractionOfCurrentIterationTime = fractionOfTotalTime - std::trunc(fractionOfTotalTime);
 
-    qreal currentPosition = percentOfAnimation * (m_count - 1);
-    int endElem   = qCeil(currentPosition);
+    qreal currentIndexPosition = fractionOfCurrentIterationTime * (m_count - 1);
+    int endElem = qCeil(currentIndexPosition);
     int startElem = qMax(endElem - 1, 0);
 
+    qreal fractionOfCurrentElement = currentIndexPosition - std::trunc(currentIndexPosition);
+
     switch(m_type)
     {
     case Translate: {
@@ -685,9 +703,9 @@ void QSvgAnimateTransform::resolveMatrix(const QSvgNode *node)
         to1   = m_args[endElem++];
         to2   = m_args[endElem++];
 
-        qreal transXDiff = (to1-from1) * percentOfAnimation;
+        qreal transXDiff = (to1 - from1) * fractionOfCurrentElement;
         qreal transX = from1 + transXDiff;
-        qreal transYDiff = (to2-from2) * percentOfAnimation;
+        qreal transYDiff = (to2 - from2) * fractionOfCurrentElement;
         qreal transY = from2 + transYDiff;
         m_transform = QTransform();
         m_transform.translate(transX, transY);
@@ -703,9 +721,9 @@ void QSvgAnimateTransform::resolveMatrix(const QSvgNode *node)
         to1   = m_args[endElem++];
         to2   = m_args[endElem++];
 
-        qreal transXDiff = (to1-from1) * percentOfAnimation;
+        qreal transXDiff = (to1 - from1) * fractionOfCurrentElement;
         qreal transX = from1 + transXDiff;
-        qreal transYDiff = (to2-from2) * percentOfAnimation;
+        qreal transYDiff = (to2 - from2) * fractionOfCurrentElement;
         qreal transY = from2 + transYDiff;
         if (transY == 0)
             transY = transX;
@@ -725,12 +743,12 @@ void QSvgAnimateTransform::resolveMatrix(const QSvgNode *node)
         to2   = m_args[endElem++];
         to3   = m_args[endElem++];
 
-        qreal rotationDiff = (to1 - from1) * percentOfAnimation;
+        qreal rotationDiff = (to1 - from1) * fractionOfCurrentElement;
         //qreal rotation = from1 + rotationDiff;
 
-        qreal transXDiff = (to2-from2) * percentOfAnimation;
+        qreal transXDiff = (to2 - from2) * fractionOfCurrentElement;
         qreal transX = from2 + transXDiff;
-        qreal transYDiff = (to3-from3) * percentOfAnimation;
+        qreal transYDiff = (to3 - from3) * fractionOfCurrentElement;
         qreal transY = from3 + transYDiff;
         m_transform = QTransform();
         m_transform.translate(transX, transY);
@@ -746,7 +764,7 @@ void QSvgAnimateTransform::resolveMatrix(const QSvgNode *node)
         from1 = m_args[startElem++];
         to1   = m_args[endElem++];
 
-        qreal transXDiff = (to1-from1) * percentOfAnimation;
+        qreal transXDiff = (to1 - from1) * fractionOfCurrentElement;
         qreal transX = from1 + transXDiff;
         m_transform = QTransform();
         m_transform.shear(qTan(qDegreesToRadians(transX)), 0);
@@ -760,8 +778,7 @@ void QSvgAnimateTransform::resolveMatrix(const QSvgNode *node)
         from1 = m_args[startElem++];
         to1   = m_args[endElem++];
 
-
-        qreal transYDiff = (to1 - from1) * percentOfAnimation;
+        qreal transYDiff = (to1 - from1) * fractionOfCurrentElement;
         qreal transY = from1 + transYDiff;
         m_transform = QTransform();
         m_transform.shear(0, qTan(qDegreesToRadians(transY)));
diff --git a/src/svg/qsvgstyle_p.h b/src/svg/qsvgstyle_p.h
index 20bd6d5..77fbe6d 100644
--- a/src/svg/qsvgstyle_p.h
+++ b/src/svg/qsvgstyle_p.h
@@ -30,6 +30,7 @@ class QPainter;
 class QSvgNode;
 class QSvgFont;
 class QSvgTinyDocument;
+class QSvgPattern;
 
 template <class T> class QSvgRefCounter
 {
@@ -74,11 +75,13 @@ public:
     inline T *operator->() const { return t; }
     inline operator T*() const { return t; }
 
+    inline bool isDefault() const { return !t || t->isDefault(); }
+
 private:
     T *t;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgRefCounted
+class Q_SVG_EXPORT QSvgRefCounted
 {
 public:
     QSvgRefCounted() { _ref = 0; }
@@ -98,7 +101,7 @@ private:
     int _ref;
 };
 
-struct Q_SVG_PRIVATE_EXPORT QSvgExtraStates
+struct Q_SVG_EXPORT QSvgExtraStates
 {
     QSvgExtraStates();
 
@@ -113,9 +116,10 @@ struct Q_SVG_PRIVATE_EXPORT QSvgExtraStates
     int nestedUseCount = 0;
     bool vectorEffect; // true if pen is cosmetic
     qint8 imageRendering; // QSvgQualityStyle::ImageRendering
+    bool inUse = false; // true if currently in QSvgUseNode
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgStyleProperty : public QSvgRefCounted
+class Q_SVG_EXPORT QSvgStyleProperty : public QSvgRefCounted
 {
 public:
     enum Type
@@ -127,6 +131,7 @@ public:
         STROKE,
         SOLID_COLOR,
         GRADIENT,
+        PATTERN,
         TRANSFORM,
         ANIMATE_TRANSFORM,
         ANIMATE_COLOR,
@@ -138,17 +143,18 @@ public:
     virtual void apply(QPainter *p, const QSvgNode *node, QSvgExtraStates &states) = 0;
     virtual void revert(QPainter *p, QSvgExtraStates &states) =0;
     virtual Type type() const=0;
+    bool isDefault() const { return false; } // [not virtual since called from templated class]
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgFillStyleProperty : public QSvgStyleProperty
+class Q_SVG_EXPORT QSvgPaintStyleProperty : public QSvgStyleProperty
 {
 public:
-    virtual QBrush brush(QPainter *p, QSvgExtraStates &states) = 0;
+    virtual QBrush brush(QPainter *p, const QSvgNode *node, QSvgExtraStates &states) = 0;
     void apply(QPainter *p, const QSvgNode *node, QSvgExtraStates &states) override;
     void revert(QPainter *p, QSvgExtraStates &states) override;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgQualityStyle : public QSvgStyleProperty
+class Q_SVG_EXPORT QSvgQualityStyle : public QSvgStyleProperty
 {
 public:
     enum ImageRendering: qint8 {
@@ -190,19 +196,22 @@ private:
 
 
 
-class Q_SVG_PRIVATE_EXPORT QSvgOpacityStyle : public QSvgStyleProperty
+class Q_SVG_EXPORT QSvgOpacityStyle : public QSvgStyleProperty
 {
 public:
     QSvgOpacityStyle(qreal opacity);
     void apply(QPainter *p, const QSvgNode *node, QSvgExtraStates &states) override;
     void revert(QPainter *p, QSvgExtraStates &states) override;
     Type type() const override;
+    qreal opacity() const { return m_opacity; }
+    bool isDefault() const { return qFuzzyCompare(m_opacity, 1.0); }
+
 private:
     qreal m_opacity;
     qreal m_oldOpacity;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgFillStyle : public QSvgStyleProperty
+class Q_SVG_EXPORT QSvgFillStyle : public QSvgStyleProperty
 {
 public:
     QSvgFillStyle();
@@ -212,7 +221,7 @@ public:
 
     void setFillRule(Qt::FillRule f);
     void setFillOpacity(qreal opacity);
-    void setFillStyle(QSvgFillStyleProperty* style);
+    void setFillStyle(QSvgPaintStyleProperty* style);
     void setBrush(QBrush brush);
 
     const QBrush & qbrush() const
@@ -230,29 +239,29 @@ public:
         return m_fillRule;
     }
 
-    QSvgFillStyleProperty* style() const
+    QSvgPaintStyleProperty* style() const
     {
         return m_style;
     }
 
-    void setGradientId(const QString &Id)
+    void setPaintStyleId(const QString &Id)
     {
-        m_gradientId = Id;
+        m_paintStyleId = Id;
     }
 
-    QString gradientId() const
+    QString paintStyleId() const
     {
-        return m_gradientId;
+        return m_paintStyleId;
     }
 
-    void setGradientResolved(bool resolved)
+    void setPaintStyleResolved(bool resolved)
     {
-        m_gradientResolved = resolved;
+        m_paintStyleResolved = resolved;
     }
 
-    bool isGradientResolved() const
+    bool isPaintStyleResolved() const
     {
-        return m_gradientResolved;
+        return m_paintStyleResolved;
     }
 
 private:
@@ -260,22 +269,22 @@ private:
     // fill-opacity    v 	v 	'inherit' | <OpacityValue.datatype>
     QBrush m_fill;
     QBrush m_oldFill;
-    QSvgFillStyleProperty *m_style;
+    QSvgPaintStyleProperty *m_style;
 
     Qt::FillRule m_fillRule;
     Qt::FillRule m_oldFillRule;
     qreal m_fillOpacity;
     qreal m_oldFillOpacity;
 
-    QString m_gradientId;
-    uint m_gradientResolved : 1;
+    QString m_paintStyleId;
+    uint m_paintStyleResolved : 1;
 
     uint m_fillRuleSet : 1;
     uint m_fillOpacitySet : 1;
     uint m_fillSet : 1;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgViewportFillStyle : public QSvgStyleProperty
+class Q_SVG_EXPORT QSvgViewportFillStyle : public QSvgStyleProperty
 {
 public:
     QSvgViewportFillStyle(const QBrush &brush);
@@ -295,7 +304,7 @@ private:
     QBrush m_oldFill;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgFontStyle : public QSvgStyleProperty
+class Q_SVG_EXPORT QSvgFontStyle : public QSvgStyleProperty
 {
 public:
     static const int LIGHTER = -1;
@@ -377,7 +386,7 @@ private:
     uint m_textAnchorSet : 1;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgStrokeStyle : public QSvgStyleProperty
+class Q_SVG_EXPORT QSvgStrokeStyle : public QSvgStyleProperty
 {
 public:
     QSvgStrokeStyle();
@@ -392,7 +401,7 @@ public:
         m_strokeSet = 1;
     }
 
-    void setStyle(QSvgFillStyleProperty *style)
+    void setStyle(QSvgPaintStyleProperty *style)
     {
         m_style = style;
         m_strokeSet = 1;
@@ -454,29 +463,29 @@ public:
         m_vectorEffectSet = 1;
     }
 
-    QSvgFillStyleProperty* style() const
+    QSvgPaintStyleProperty* style() const
     {
         return m_style;
     }
 
-    void setGradientId(const QString &Id)
+    void setPaintStyleId(const QString &Id)
     {
-        m_gradientId = Id;
+        m_paintStyleId = Id;
     }
 
-    QString gradientId() const
+    QString paintStyleId() const
     {
-        return m_gradientId;
+        return m_paintStyleId;
     }
 
-    void setGradientResolved(bool resolved)
+    void setPaintStyleResolved(bool resolved)
     {
-        m_gradientResolved = resolved;
+        m_paintStyleResolved = resolved;
     }
 
-    bool isGradientResolved() const
+    bool isPaintStyleResolved() const
     {
-        return m_gradientResolved;
+        return m_paintStyleResolved;
     }
 
     QPen stroke() const
@@ -500,9 +509,9 @@ private:
     qreal m_strokeDashOffset;
     qreal m_oldStrokeDashOffset;
 
-    QSvgFillStyleProperty *m_style;
-    QString m_gradientId;
-    uint m_gradientResolved : 1;
+    QSvgPaintStyleProperty *m_style;
+    QString m_paintStyleId;
+    uint m_paintStyleResolved : 1;
     uint m_vectorEffect : 1;
     uint m_oldVectorEffect : 1;
 
@@ -517,7 +526,7 @@ private:
     uint m_vectorEffectSet : 1;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgSolidColorStyle : public QSvgFillStyleProperty
+class Q_SVG_EXPORT QSvgSolidColorStyle : public QSvgPaintStyleProperty
 {
 public:
     QSvgSolidColorStyle(const QColor &color);
@@ -528,7 +537,7 @@ public:
         return m_solidColor;
     }
 
-    QBrush brush(QPainter *, QSvgExtraStates &) override
+    QBrush brush(QPainter *, const QSvgNode *, QSvgExtraStates &) override
     {
         return m_solidColor;
     }
@@ -542,7 +551,7 @@ private:
     QPen   m_oldStroke;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgGradientStyle : public QSvgFillStyleProperty
+class Q_SVG_EXPORT QSvgGradientStyle : public QSvgPaintStyleProperty
 {
 public:
     QSvgGradientStyle(QGradient *grad);
@@ -575,7 +584,7 @@ public:
         m_gradientStopsSet = set;
     }
 
-    QBrush brush(QPainter *, QSvgExtraStates &) override;
+    QBrush brush(QPainter *, const QSvgNode *, QSvgExtraStates &) override;
 private:
     QGradient      *m_gradient;
     QTransform m_transform;
@@ -585,7 +594,23 @@ private:
     bool m_gradientStopsSet;
 };
 
-class Q_SVG_PRIVATE_EXPORT QSvgTransformStyle : public QSvgStyleProperty
+class Q_SVG_EXPORT QSvgPatternStyle : public QSvgPaintStyleProperty
+{
+public:
+    QSvgPatternStyle(QSvgPattern *pattern);
+    ~QSvgPatternStyle() = default;
+    Type type() const override;
+
+    QBrush brush(QPainter *, const QSvgNode *, QSvgExtraStates &) override;
+    QSvgPattern *patternNode() { return m_pattern; }
+private:
+    QSvgPattern *m_pattern;
+    QImage m_patternImage;
+    QRectF m_parentBound;
+};
+
+
+class Q_SVG_EXPORT QSvgTransformStyle : public QSvgStyleProperty
 {
 public:
     QSvgTransformStyle(const QTransform &transform);
@@ -597,6 +622,7 @@ public:
     {
         return m_transform;
     }
+    bool isDefault() const { return m_transform.isIdentity(); }
 private:
     //7.6 The transform  attribute
     QTransform m_transform;
@@ -604,7 +630,7 @@ private:
 };
 
 
-class Q_SVG_PRIVATE_EXPORT QSvgAnimateTransform : public QSvgStyleProperty
+class Q_SVG_EXPORT QSvgAnimateTransform : public QSvgStyleProperty
 {
 public:
     enum TransformType
@@ -677,7 +703,7 @@ private:
 };
 
 
-class Q_SVG_PRIVATE_EXPORT QSvgAnimateColor : public QSvgStyleProperty
+class Q_SVG_EXPORT QSvgAnimateColor : public QSvgStyleProperty
 {
 public:
     QSvgAnimateColor(int startMs, int endMs, int by = 0);
@@ -700,7 +726,7 @@ private:
 };
 
 
-class Q_SVG_PRIVATE_EXPORT QSvgCompOpStyle : public QSvgStyleProperty
+class Q_SVG_EXPORT QSvgCompOpStyle : public QSvgStyleProperty
 {
 public:
     QSvgCompOpStyle(QPainter::CompositionMode mode);
@@ -720,7 +746,7 @@ private:
 };
 
 
-class Q_SVG_PRIVATE_EXPORT QSvgStyle
+class Q_SVG_EXPORT QSvgStyle
 {
 public:
     QSvgStyle()
@@ -731,6 +757,7 @@ public:
           stroke(0),
           solidColor(0),
           gradient(0),
+          pattern(0),
           transform(0),
           animateColor(0),
           opacity(0),
@@ -747,6 +774,7 @@ public:
     QSvgRefCounter<QSvgStrokeStyle>       stroke;
     QSvgRefCounter<QSvgSolidColorStyle>   solidColor;
     QSvgRefCounter<QSvgGradientStyle>     gradient;
+    QSvgRefCounter<QSvgPatternStyle>      pattern;
     QSvgRefCounter<QSvgTransformStyle>    transform;
     QSvgRefCounter<QSvgAnimateColor>      animateColor;
     QList<QSvgRefCounter<QSvgAnimateTransform> >   animateTransforms;
diff --git a/src/svg/qsvgtinydocument.cpp b/src/svg/qsvgtinydocument.cpp
index 176ff3c..94f21ca 100644
--- a/src/svg/qsvgtinydocument.cpp
+++ b/src/svg/qsvgtinydocument.cpp
@@ -21,7 +21,9 @@
 
 QT_BEGIN_NAMESPACE
 
-QSvgTinyDocument::QSvgTinyDocument()
+using namespace Qt::StringLiterals;
+
+QSvgTinyDocument::QSvgTinyDocument(QtSvg::Options options)
     : QSvgStructureNode(0)
     , m_widthPercent(false)
     , m_heightPercent(false)
@@ -29,6 +31,7 @@ QSvgTinyDocument::QSvgTinyDocument()
     , m_animated(false)
     , m_animationDuration(0)
     , m_fps(30)
+    , m_options(options)
 {
 }
 
@@ -36,6 +39,19 @@ QSvgTinyDocument::~QSvgTinyDocument()
 {
 }
 
+static bool hasSvgHeader(const QByteArray &buf)
+{
+    QTextStream s(buf); // Handle multi-byte encodings
+    QString h = s.readAll();
+    QStringView th = QStringView(h).trimmed();
+    bool matched = false;
+    if (th.startsWith("<svg"_L1) || th.startsWith("<!DOCTYPE svg"_L1))
+        matched = true;
+    else if (th.startsWith("<?xml"_L1) || th.startsWith("<!--"_L1))
+        matched = th.contains("<!DOCTYPE svg"_L1) || th.contains("<svg"_L1);
+    return matched;
+}
+
 #ifndef QT_NO_COMPRESS
 static QByteArray qt_inflateSvgzDataFrom(QIODevice *device, bool doCheckContent = true);
 #   ifdef QT_BUILD_INTERNAL
@@ -123,8 +139,7 @@ static QByteArray qt_inflateSvgzDataFrom(QIODevice *device, bool doCheckContent)
 
         if (doCheckContent) {
             // Quick format check, equivalent to QSvgIOHandler::canRead()
-            QByteArray buf = destination.left(16);
-            if (!buf.contains("<?xml") && !buf.contains("<svg") && !buf.contains("<!--") && !buf.contains("<!DOCTYPE svg")) {
+            if (!hasSvgHeader(destination)) {
                 inflateEnd(&zlibStream);
                 qCWarning(lcSvgHandler, "Error while inflating gzip file: SVG format check failed");
                 return QByteArray();
@@ -152,7 +167,7 @@ static QByteArray qt_inflateSvgzDataFrom(QIODevice *)
 }
 #endif
 
-QSvgTinyDocument * QSvgTinyDocument::load(const QString &fileName)
+QSvgTinyDocument *QSvgTinyDocument::load(const QString &fileName, QtSvg::Options options)
 {
     QFile file(fileName);
     if (!file.open(QFile::ReadOnly)) {
@@ -167,7 +182,7 @@ QSvgTinyDocument * QSvgTinyDocument::load(const QString &fileName)
     }
 
     QSvgTinyDocument *doc = nullptr;
-    QSvgHandler handler(&file);
+    QSvgHandler handler(&file, options);
     if (handler.ok()) {
         doc = handler.document();
         doc->m_animationDuration = handler.animationDuration();
@@ -179,7 +194,7 @@ QSvgTinyDocument * QSvgTinyDocument::load(const QString &fileName)
     return doc;
 }
 
-QSvgTinyDocument * QSvgTinyDocument::load(const QByteArray &contents)
+QSvgTinyDocument *QSvgTinyDocument::load(const QByteArray &contents, QtSvg::Options options)
 {
     QByteArray svg;
     // Check for gzip magic number and inflate if appropriate
@@ -196,7 +211,7 @@ QSvgTinyDocument * QSvgTinyDocument::load(const QByteArray &contents)
     QBuffer buffer;
     buffer.setData(svg);
     buffer.open(QIODevice::ReadOnly);
-    QSvgHandler handler(&buffer);
+    QSvgHandler handler(&buffer, options);
 
     QSvgTinyDocument *doc = nullptr;
     if (handler.ok()) {
@@ -208,9 +223,9 @@ QSvgTinyDocument * QSvgTinyDocument::load(const QByteArray &contents)
     return doc;
 }
 
-QSvgTinyDocument * QSvgTinyDocument::load(QXmlStreamReader *contents)
+QSvgTinyDocument *QSvgTinyDocument::load(QXmlStreamReader *contents, QtSvg::Options options)
 {
-    QSvgHandler handler(contents);
+    QSvgHandler handler(contents, options);
 
     QSvgTinyDocument *doc = nullptr;
     if (handler.ok()) {
@@ -234,12 +249,7 @@ void QSvgTinyDocument::draw(QPainter *p, const QRectF &bounds)
     //sets default style on the painter
     //### not the most optimal way
     mapSourceToTarget(p, bounds);
-    QPen pen(Qt::NoBrush, 1, Qt::SolidLine, Qt::FlatCap, Qt::SvgMiterJoin);
-    pen.setMiterLimit(4);
-    p->setPen(pen);
-    p->setBrush(Qt::black);
-    p->setRenderHint(QPainter::Antialiasing);
-    p->setRenderHint(QPainter::SmoothPixmapTransform);
+    initPainter(p);
     QList<QSvgNode*>::iterator itr = m_renderers.begin();
     applyStyle(p, m_states);
     while (itr != m_renderers.end()) {
@@ -310,10 +320,9 @@ void QSvgTinyDocument::draw(QPainter *p, const QString &id,
     p->restore();
 }
 
-
 QSvgNode::Type QSvgTinyDocument::type() const
 {
-    return DOC;
+    return Doc;
 }
 
 void QSvgTinyDocument::setWidth(int len, bool percent)
@@ -339,6 +348,11 @@ void QSvgTinyDocument::setViewBox(const QRectF &rect)
     m_implicitViewBox = rect.isNull();
 }
 
+QtSvg::Options QSvgTinyDocument::options() const
+{
+    return m_options;
+}
+
 void QSvgTinyDocument::addSvgFont(QSvgFont *font)
 {
     m_fonts.insert(font->familyName(), font);
@@ -359,7 +373,7 @@ QSvgNode *QSvgTinyDocument::namedNode(const QString &id) const
     return m_namedNodes.value(id);
 }
 
-void QSvgTinyDocument::addNamedStyle(const QString &id, QSvgFillStyleProperty *style)
+void QSvgTinyDocument::addNamedStyle(const QString &id, QSvgPaintStyleProperty *style)
 {
     if (!m_namedStyles.contains(id))
         m_namedStyles.insert(id, style);
@@ -367,7 +381,7 @@ void QSvgTinyDocument::addNamedStyle(const QString &id, QSvgFillStyleProperty *s
         qCWarning(lcSvgHandler) << "Duplicate unique style id:" << id;
 }
 
-QSvgFillStyleProperty *QSvgTinyDocument::namedStyle(const QString &id) const
+QSvgPaintStyleProperty *QSvgTinyDocument::namedStyle(const QString &id) const
 {
     return m_namedStyles.value(id);
 }
@@ -392,7 +406,7 @@ void QSvgTinyDocument::draw(QPainter *p)
     draw(p, QRectF());
 }
 
-void QSvgTinyDocument::draw(QPainter *, QSvgExtraStates &)
+void QSvgTinyDocument::drawCommand(QPainter *, QSvgExtraStates &)
 {
     qCDebug(lcSvgHandler) << "SVG Tiny does not support nested <svg> elements: ignored.";
     return;
@@ -521,4 +535,39 @@ void QSvgTinyDocument::setFramesPerSecond(int num)
     m_fps = num;
 }
 
+bool QSvgTinyDocument::isLikelySvg(QIODevice *device, bool *isCompressed)
+{
+    constexpr int bufSize = 4096;
+    char buf[bufSize];
+    char inflateBuf[bufSize];
+    bool useInflateBuf = false;
+    int readLen = device->peek(buf, bufSize);
+    if (readLen < 8)
+        return false;
+#ifndef QT_NO_COMPRESS
+    if (quint8(buf[0]) == 0x1f && quint8(buf[1]) == 0x8b) {
+        // Indicates gzip compressed content, i.e. svgz
+        z_stream zlibStream;
+        zlibStream.avail_in = readLen;
+        zlibStream.next_out = reinterpret_cast<Bytef *>(inflateBuf);
+        zlibStream.avail_out = bufSize;
+        zlibStream.next_in = reinterpret_cast<Bytef *>(buf);
+        zlibStream.zalloc = Z_NULL;
+        zlibStream.zfree = Z_NULL;
+        zlibStream.opaque = Z_NULL;
+        if (inflateInit2(&zlibStream, MAX_WBITS + 16) != Z_OK)
+            return false;
+        int zlibResult = inflate(&zlibStream, Z_NO_FLUSH);
+        inflateEnd(&zlibStream);
+        if ((zlibResult != Z_OK && zlibResult != Z_STREAM_END) || zlibStream.total_out < 8)
+            return false;
+        readLen = zlibStream.total_out;
+        if (isCompressed)
+            *isCompressed = true;
+        useInflateBuf = true;
+    }
+#endif
+    return hasSvgHeader(QByteArray::fromRawData(useInflateBuf ? inflateBuf : buf, readLen));
+}
+
 QT_END_NAMESPACE
diff --git a/src/svg/qsvgtinydocument_p.h b/src/svg/qsvgtinydocument_p.h
index 99984f5..a3f5489 100644
--- a/src/svg/qsvgtinydocument_p.h
+++ b/src/svg/qsvgtinydocument_p.h
@@ -33,32 +33,35 @@ class QByteArray;
 class QSvgFont;
 class QTransform;
 
-class Q_SVG_PRIVATE_EXPORT QSvgTinyDocument : public QSvgStructureNode
+class Q_SVG_EXPORT QSvgTinyDocument : public QSvgStructureNode
 {
 public:
-    static QSvgTinyDocument * load(const QString &file);
-    static QSvgTinyDocument * load(const QByteArray &contents);
-    static QSvgTinyDocument * load(QXmlStreamReader *contents);
+    static QSvgTinyDocument *load(const QString &file, QtSvg::Options options = {});
+    static QSvgTinyDocument *load(const QByteArray &contents, QtSvg::Options options = {});
+    static QSvgTinyDocument *load(QXmlStreamReader *contents, QtSvg::Options options = {});
+    static bool isLikelySvg(QIODevice *device, bool *isCompressed = nullptr);
 public:
-    QSvgTinyDocument();
+    QSvgTinyDocument(QtSvg::Options options);
     ~QSvgTinyDocument();
     Type type() const override;
 
-    QSize size() const;
+    inline QSize size() const;
     void setWidth(int len, bool percent);
     void setHeight(int len, bool percent);
-    int width() const;
-    int height() const;
-    bool widthPercent() const;
-    bool heightPercent() const;
+    inline int width() const;
+    inline int height() const;
+    inline bool widthPercent() const;
+    inline bool heightPercent() const;
 
-    bool preserveAspectRatio() const;
+    inline bool preserveAspectRatio() const;
     void setPreserveAspectRatio(bool on);
 
-    QRectF viewBox() const;
+    inline QRectF viewBox() const;
     void setViewBox(const QRectF &rect);
 
-    void draw(QPainter *p, QSvgExtraStates &) override; //from the QSvgNode
+    QtSvg::Options options() const;
+
+    void drawCommand(QPainter *, QSvgExtraStates &) override;
 
     void draw(QPainter *p);
     void draw(QPainter *p, const QRectF &bounds);
@@ -73,17 +76,18 @@ public:
     QSvgFont *svgFont(const QString &family) const;
     void addNamedNode(const QString &id, QSvgNode *node);
     QSvgNode *namedNode(const QString &id) const;
-    void addNamedStyle(const QString &id, QSvgFillStyleProperty *style);
-    QSvgFillStyleProperty *namedStyle(const QString &id) const;
+    void addNamedStyle(const QString &id, QSvgPaintStyleProperty *style);
+    QSvgPaintStyleProperty *namedStyle(const QString &id) const;
 
     void restartAnimation();
-    int currentElapsed() const;
+    inline int currentElapsed() const;
     bool animated() const;
     void setAnimated(bool a);
-    int animationDuration() const;
+    inline int animationDuration() const;
     int currentFrame() const;
     void setCurrentFrame(int);
     void setFramesPerSecond(int num);
+
 private:
     void mapSourceToTarget(QPainter *p, const QRectF &targetRect, const QRectF &sourceRect = QRectF());
 private:
@@ -97,7 +101,7 @@ private:
 
     QHash<QString, QSvgRefCounter<QSvgFont> > m_fonts;
     QHash<QString, QSvgNode *> m_namedNodes;
-    QHash<QString, QSvgRefCounter<QSvgFillStyleProperty> > m_namedStyles;
+    QHash<QString, QSvgRefCounter<QSvgPaintStyleProperty> > m_namedStyles;
 
     qint64 m_time;
     bool  m_animated;
@@ -105,8 +109,12 @@ private:
     int   m_fps;
 
     QSvgExtraStates m_states;
+
+    const QtSvg::Options m_options;
 };
 
+Q_SVG_EXPORT QDebug operator<<(QDebug debug, const QSvgTinyDocument &doc);
+
 inline QSize QSvgTinyDocument::size() const
 {
     if (m_size.isEmpty())
diff --git a/src/svg/qsvgvisitor.cpp b/src/svg/qsvgvisitor.cpp
new file mode 100644
index 0000000..018ace0
--- /dev/null
+++ b/src/svg/qsvgvisitor.cpp
@@ -0,0 +1,127 @@
+// Copyright (C) 2023 The Qt Company Ltd.
+// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
+
+#include "qsvgvisitor_p.h"
+
+QT_BEGIN_NAMESPACE
+
+void QSvgVisitor::traverse(const QSvgStructureNode *node)
+{
+    switch (node->type()) {
+    case QSvgNode::Switch:
+        if (!visitSwitchNodeStart(static_cast<const QSvgSwitch *>(node)))
+            return;
+        break;
+    case QSvgNode::Doc:
+        if (!visitDocumentNodeStart(static_cast<const QSvgTinyDocument *>(node)))
+            return;
+        break;
+    case QSvgNode::Defs:
+        if (!visitDefsNodeStart(static_cast<const QSvgDefs *>(node)))
+            return;
+        break;
+    case QSvgNode::Group:
+        if (!visitGroupNodeStart(static_cast<const QSvgG *>(node)))
+            return;
+        break;
+    case QSvgNode::Mask:
+        if (!visitMaskNodeStart(static_cast<const QSvgMask *>(node)))
+            return;
+        break;
+    default:
+        Q_UNREACHABLE();
+        break;
+    }
+
+    for (const auto *child : node->renderers())
+        traverse(child);
+
+    switch (node->type()) {
+    case QSvgNode::Switch:
+        visitSwitchNodeEnd(static_cast<const QSvgSwitch *>(node));
+        break;
+    case QSvgNode::Doc:
+        visitDocumentNodeEnd(static_cast<const QSvgTinyDocument *>(node));
+        break;
+    case QSvgNode::Defs:
+        visitDefsNodeEnd(static_cast<const QSvgDefs *>(node));
+        break;
+    case QSvgNode::Group:
+        visitGroupNodeEnd(static_cast<const QSvgG *>(node));
+        break;
+    case QSvgNode::Mask:
+        visitMaskNodeEnd(static_cast<const QSvgMask *>(node));
+        break;
+    default:
+        Q_UNREACHABLE();
+        break;
+    }
+}
+
+void QSvgVisitor::traverse(const QSvgNode *node)
+{
+    switch (node->type()) {
+    case QSvgNode::Switch:
+    case QSvgNode::Doc:
+    case QSvgNode::Defs:
+    case QSvgNode::Group:
+    case QSvgNode::Mask:
+        traverse(static_cast<const QSvgStructureNode *>(node));
+        break;
+    case QSvgNode::Animation:
+        visitAnimationNode(static_cast<const QSvgAnimation *>(node));
+        break;
+    case QSvgNode::Circle:
+    case QSvgNode::Ellipse:
+        visitEllipseNode(static_cast<const QSvgEllipse *>(node));
+        break;
+    case QSvgNode::Image:
+        visitImageNode(static_cast<const QSvgImage *>(node));
+        break;
+    case QSvgNode::Line:
+        visitLineNode(static_cast<const QSvgLine *>(node));
+        break;
+    case QSvgNode::Path:
+        visitPathNode(static_cast<const QSvgPath *>(node));
+        break;
+    case QSvgNode::Polygon:
+        visitPolygonNode(static_cast<const QSvgPolygon *>(node));
+        break;
+    case QSvgNode::Polyline:
+        visitPolylineNode(static_cast<const QSvgPolyline *>(node));
+        break;
+    case QSvgNode::Rect:
+        visitRectNode(static_cast<const QSvgRect *>(node));
+        break;
+    case QSvgNode::Text:
+    case QSvgNode::Textarea:
+        visitTextNode(static_cast<const QSvgText *>(node));
+        break;
+    case QSvgNode::Tspan:
+        visitTspanNode(static_cast<const QSvgTspan *>(node));
+        break;
+    case QSvgNode::Use:
+        visitUseNode(static_cast<const QSvgUse *>(node));
+        break;
+    case QSvgNode::Video:
+        visitVideoNode(static_cast<const QSvgVideo *>(node));
+        break;
+
+        // Enum values that don't have any QSvgNode classes yet:
+    case QSvgNode::Symbol:
+    case QSvgNode::Marker:
+    case QSvgNode::Pattern:
+    case QSvgNode::Filter:
+    case QSvgNode::FeMerge:
+    case QSvgNode::FeMergenode:
+    case QSvgNode::FeColormatrix:
+    case QSvgNode::FeGaussianblur:
+    case QSvgNode::FeOffset:
+    case QSvgNode::FeComposite:
+    case QSvgNode::FeFlood:
+        qDebug() << "Unhandled type in switch" << node->type();
+        break;
+    }
+}
+
+QT_END_NAMESPACE
diff --git a/src/svg/qsvgvisitor_p.h b/src/svg/qsvgvisitor_p.h
new file mode 100644
index 0000000..e1d0663
--- /dev/null
+++ b/src/svg/qsvgvisitor_p.h
@@ -0,0 +1,63 @@
+// Copyright (C) 2023 The Qt Company Ltd.
+// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
+
+#ifndef QSVGVISITOR_P_H
+#define  QSVGVISITOR_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <private/qsvgtinydocument_p.h>
+#include <private/qsvghandler_p.h>
+#include <private/qsvggraphics_p.h>
+#include <private/qsvgstructure_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class Q_SVG_EXPORT QSvgVisitor {
+public:
+    void traverse(const QSvgStructureNode *node);
+    void traverse(const QSvgNode *node);
+
+    virtual ~QSvgVisitor() {}
+
+protected:
+    virtual void visitNode(const QSvgNode *) {}
+    virtual bool visitStructureNodeStart(const QSvgStructureNode *node) { visitNode(node); return true; }
+    virtual void visitStructureNodeEnd(const QSvgStructureNode *) {}
+    virtual void visitAnimationNode(const QSvgAnimation *node) { visitNode(node); }
+    virtual void visitEllipseNode(const QSvgEllipse *node) { visitNode(node); }
+    virtual void visitImageNode(const QSvgImage *node) { visitNode(node); }
+    virtual void visitLineNode(const QSvgLine *node) { visitNode(node); }
+    virtual void visitPathNode(const QSvgPath *node) { visitNode(node); }
+    virtual void visitPolygonNode(const QSvgPolygon *node) { visitNode(node); }
+    virtual void visitPolylineNode(const QSvgPolyline *node) { visitNode(node); }
+    virtual void visitRectNode(const QSvgRect *node) { visitNode(node); }
+    virtual void visitTextNode(const QSvgText *node) { visitNode(node); }
+    virtual void visitTspanNode(const QSvgTspan *node) { visitNode(node); }
+    virtual void visitUseNode(const QSvgUse *node) { visitNode(node); }
+    virtual void visitVideoNode(const QSvgVideo *node) { visitNode(node); }
+
+    virtual bool visitDocumentNodeStart(const QSvgTinyDocument *node) { return visitStructureNodeStart(node); }
+    virtual void visitDocumentNodeEnd(const QSvgTinyDocument *node) { visitStructureNodeEnd(node); }
+    virtual bool visitGroupNodeStart(const QSvgG *node) { return visitStructureNodeStart(node); }
+    virtual void visitGroupNodeEnd(const QSvgG *node)  { visitStructureNodeEnd(node); }
+    virtual bool visitDefsNodeStart(const QSvgDefs *node) { return visitStructureNodeStart(node); }
+    virtual void visitDefsNodeEnd(const QSvgDefs *node)  { visitStructureNodeEnd(node); };
+    virtual bool visitSwitchNodeStart(const QSvgSwitch *node) { return visitStructureNodeStart(node); }
+    virtual void visitSwitchNodeEnd(const QSvgSwitch *node)  { visitStructureNodeEnd(node); };
+    virtual bool visitMaskNodeStart(const QSvgMask *node) { return visitStructureNodeStart(node); }
+    virtual void visitMaskNodeEnd(const QSvgMask *node) { visitStructureNodeEnd(node); }
+};
+
+QT_END_NAMESPACE
+
+#endif // QSVGVISITOR_P_H
diff --git a/src/svg/qtsvgglobal.h b/src/svg/qtsvgglobal.h
index 985a7aa..8154e0a 100644
--- a/src/svg/qtsvgglobal.h
+++ b/src/svg/qtsvgglobal.h
@@ -1,4 +1,5 @@
 // Copyright (C) 2016 Intel Corporation.
+// Copyright (C) 2023 The Qt Company Ltd.
 // SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
 
 #ifndef QTSVGGLOBAL_H
@@ -7,4 +8,19 @@
 #include <QtCore/qglobal.h>
 #include <QtSvg/qtsvgexports.h>
 
+QT_BEGIN_NAMESPACE
+
+namespace QtSvg {
+
+enum Option : quint32 {
+    NoOption           = 0x00,
+    Tiny12FeaturesOnly = 0x01
+};
+Q_DECLARE_FLAGS(Options, Option)
+Q_DECLARE_OPERATORS_FOR_FLAGS(Options)
+
+}
+
+QT_END_NAMESPACE
+
 #endif
diff --git a/src/svg/qtsvgglobal_p.h b/src/svg/qtsvgglobal_p.h
index f82ee60..26cc72b 100644
--- a/src/svg/qtsvgglobal_p.h
+++ b/src/svg/qtsvgglobal_p.h
@@ -16,6 +16,20 @@
 //
 
 #include "qtsvgglobal.h"
-#include <QtSvg/private/qtsvgexports_p.h>
+#include <QtSvg/qtsvgexports.h>
+
+QT_BEGIN_NAMESPACE
+
+namespace QtSvg {
+
+enum class UnitTypes : quint32 {
+    unknown,
+    objectBoundingBox,
+    userSpaceOnUse
+};
+
+}
+
+QT_END_NAMESPACE
 
 #endif // QTSVGGLOBAL_P_H
diff --git a/src/svgwidgets/CMakeLists.txt b/src/svgwidgets/CMakeLists.txt
index 8708799..004d486 100644
--- a/src/svgwidgets/CMakeLists.txt
+++ b/src/svgwidgets/CMakeLists.txt
@@ -10,6 +10,7 @@ qt_internal_add_module(SvgWidgets
         qsvgwidget.cpp qsvgwidget.h
         qtsvgwidgetsglobal.h
     DEFINES
+        QT_NO_CONTEXTLESS_CONNECT
         QT_NO_USING_NAMESPACE
     LIBRARIES
         Qt::CorePrivate
diff --git a/src/svgwidgets/qsvgwidget.cpp b/src/svgwidgets/qsvgwidget.cpp
index a57bf04..99363d2 100644
--- a/src/svgwidgets/qsvgwidget.cpp
+++ b/src/svgwidgets/qsvgwidget.cpp
@@ -48,6 +48,32 @@ public:
     QSvgRenderer *renderer;
 };
 
+// Event listener for ShowEvent/HideEvent on QSvgWidget (which can't just
+// reimplement event() or showEvent()/hideEvent() or eventFilter() in case
+// a subclass doesn't call the base class in those methods)
+// ### Qt 7: remove the event filter; move this logic into showEvent/hideEvent; add event() override
+class QSvgWidgetListener : public QObject
+{
+public:
+    using QObject::QObject;
+
+protected:
+    bool eventFilter(QObject *obj, QEvent *event) override
+    {
+        if (event->type() == QEvent::Show)
+            renderer()->setAnimationEnabled(true);
+        else if (event->type() == QEvent::Hide)
+            renderer()->setAnimationEnabled(false);
+        return QObject::eventFilter(obj, event);
+    }
+
+private:
+    QSvgRenderer *renderer()
+    {
+        return static_cast<QSvgWidgetPrivate *>(QObjectPrivate::get(parent()))->renderer;
+    }
+};
+
 /*!
     Constructs a new SVG display widget with the given \a parent.
 */
@@ -57,6 +83,7 @@ QSvgWidget::QSvgWidget(QWidget *parent)
     d_func()->renderer = new QSvgRenderer(this);
     QObject::connect(d_func()->renderer, SIGNAL(repaintNeeded()),
                      this, SLOT(update()));
+    installEventFilter(new QSvgWidgetListener(this));
 }
 
 /*!
@@ -64,11 +91,9 @@ QSvgWidget::QSvgWidget(QWidget *parent)
     of the specified \a file.
 */
 QSvgWidget::QSvgWidget(const QString &file, QWidget *parent)
-    : QWidget(*new QSvgWidgetPrivate, parent, {})
+    : QSvgWidget(parent)
 {
-    d_func()->renderer = new QSvgRenderer(file, this);
-    QObject::connect(d_func()->renderer, SIGNAL(repaintNeeded()),
-                     this, SLOT(update()));
+    d_func()->renderer->load(file);
 }
 
 /*!
@@ -101,6 +126,38 @@ QSize QSvgWidget::sizeHint() const
         return QSize(128, 64);
 }
 
+/*!
+    \since 6.7
+
+    Returns the options of the widget's renderer.
+
+    \sa setOptions
+ */
+QtSvg::Options QSvgWidget::options() const
+{
+    Q_D(const QSvgWidget);
+    return d->renderer->options();
+}
+
+/*!
+    \since 6.7
+
+    Sets the widget's renderer options to \a options.
+
+    This property holds a set of QtSvg::Option flags that can be used
+    to enable or disable various features of the parsing and rendering
+    of SVG files. It must be set before calling the load function to
+    have any effect.
+
+    By default, no flags are set.
+
+    \sa options
+ */
+void QSvgWidget::setOptions(QtSvg::Options options)
+{
+    Q_D(QSvgWidget);
+    d->renderer->setOptions(options);
+}
 
 /*!
     \reimp
@@ -122,6 +179,8 @@ void QSvgWidget::load(const QString &file)
 {
     Q_D(const QSvgWidget);
     d->renderer->load(file);
+    if (!isVisible())
+        d->renderer->setAnimationEnabled(false);
 }
 
 /*!
@@ -131,6 +190,8 @@ void QSvgWidget::load(const QByteArray &contents)
 {
     Q_D(const QSvgWidget);
     d->renderer->load(contents);
+    if (!isVisible())
+        d->renderer->setAnimationEnabled(false);
 }
 
 QT_END_NAMESPACE
diff --git a/src/svgwidgets/qsvgwidget.h b/src/svgwidgets/qsvgwidget.h
index 88cf452..c4ddc8a 100644
--- a/src/svgwidgets/qsvgwidget.h
+++ b/src/svgwidgets/qsvgwidget.h
@@ -26,11 +26,15 @@ public:
     QSvgRenderer *renderer() const;
 
     QSize sizeHint() const override;
+
+    QtSvg::Options options() const;
+    void setOptions(QtSvg::Options options);
 public Q_SLOTS:
     void load(const QString &file);
     void load(const QByteArray &contents);
 protected:
     void paintEvent(QPaintEvent *event) override;
+
 private:
     Q_DISABLE_COPY(QSvgWidget)
     Q_DECLARE_PRIVATE(QSvgWidget)
diff --git a/src/svgwidgets/qtsvgwidgetsglobal.h b/src/svgwidgets/qtsvgwidgetsglobal.h
index 44a0bf8..db4c930 100644
--- a/src/svgwidgets/qtsvgwidgetsglobal.h
+++ b/src/svgwidgets/qtsvgwidgetsglobal.h
@@ -6,5 +6,6 @@
 
 #include <QtCore/qglobal.h>
 #include <QtSvgWidgets/qtsvgwidgetsexports.h>
+#include <QtSvg/qtsvgglobal.h>
 
 #endif
